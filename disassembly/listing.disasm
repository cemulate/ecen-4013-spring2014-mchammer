Disassembly Listing for Senior
Generated From:
C:/Users/Chase/Desktop/ecen-4013-spring2014-mchammer/dist/default/debug/ecen-4013-spring2014-mchammer.debug.elf
Oct 27, 2014 8:37:55 PM

---  C:/Users/Chase/Desktop/ecen-4013-spring2014-mchammer/src/radiohardware.c  --------------------------
1:                 /*
2:                 	Hardware specific code for the MRF24J40 radio on a 2.4GHz
3:                 	RF Pictail board on an Explorer16 board.
4:                 */
5:                 
6:                 #include "radiohardware.h"	
7:                 
8:                 void	RadioHW_Init()
9:                 {
0048B0  FA0000     LNK #0x0
10:                    RADIO_CS_TRIS = 0;
0048B2  A9A2C9     BCLR 0x2C9, #5
11:                    RADIO_CS = 1;
0048B4  A8A2CB     BSET 0x2CB, #5
12:                    RADIO_RESETn_TRIS = 0;
0048B6  A982C9     BCLR 0x2C9, #4
13:                    RADIO_RESETn = 1;
0048B8  A882CB     BSET 0x2CB, #4
14:                    RADIO_INT_TRIS = 1;
0048BA  A8C2C9     BSET 0x2C9, #6
15:                    RADIO_WAKE_TRIS = 0;
0048BC  A962C9     BCLR 0x2C9, #3
16:                    RADIO_WAKE = 1;
0048BE  A862CB     BSET 0x2CB, #3
17:                
18:                    RPINR0bits.INT1R = RADIO_INT_PIN_NUM;
0048C0  803405     MOV RPINR0, W5
0048C2  2E0FF4     MOV #0xE0FF, W4
0048C4  628284     AND W5, W4, W5
0048C6  20E004     MOV #0xE00, W4
0048C8  720205     IOR W4, W5, W4
0048CA  883404     MOV W4, RPINR0
19:                
20:                    #if defined(HARDWARE_SPI)
21:                
22:                    RPOR1bits.RP2R = 0b00111;       // output SDO1 to RP2
23:                    RPINR20bits.SDI1R = 3;          // input SDI1 to RP3
24:                    RPOR2bits.RP4R = 0b01000;       // output SCK1 to RP4
25:                
26:                    SPICON1 = SPICON1_VAL;
27:                    SPISTAT = SPISTAT_VAL;
28:                
29:                    #else
30:                
31:                    RADIO_SDI_TRIS = 1;
0048CC  A862C8     BSET TRISB, #3
32:                    RADIO_SDO_TRIS = 0;
0048CE  A942C8     BCLR TRISB, #2
33:                    RADIO_SCK_TRIS = 0;
0048D0  A962C0     BCLR TRISA, #3
34:                    RADIO_SPI_SDO = 0;
0048D2  A942CA     BCLR PORTB, #2
35:                    RADIO_SPI_SCK = 0;   
0048D4  A962C2     BCLR PORTA, #3
36:                
37:                    #endif
38:                }
0048D6  FA8000     ULNK
0048D8  060000     RETURN
---  C:/Users/Chase/Desktop/ecen-4013-spring2014-mchammer/src/main.c  -----------------------------------
1:                 /* 
2:                  * File:   main.c
3:                  * Author: Chase
4:                  *
5:                  * Created on October 13, 2014, 3:46 AM
6:                  */
7:                 
8:                 #include <stdio.h>
9:                 #include <stdlib.h>
10:                #include <string.h>
11:                #include <math.h>
12:                
13:                #include <xc.h>
14:                
15:                // --------------------- Configuration bits ---------------------
16:                
17:                // Configure clock settings:
18:                
19:                #pragma config FNOSC = FRC
20:                // Oscillator Mode (Internal Fast RC (FRC) with divide by N)
21:                // This is the default clock. The FRC oscillates at a nominal 7.37 MHz,
22:                // And "N" is by default 1, leaving our processor clocked at 7.37 MHz
23:                // The instruction frequency is Fosc/2 = 3.685 MHz
24:                
25:                #pragma config IESO = OFF
26:                // Internal External Switch Over Mode = OFF
27:                // Tells the processor to exclusively use the oscillator chosen above
28:                // when starting up
29:                
30:                // For previous two, see PIC24HJ64GP502 Datasheet sec. 9
31:                
32:                #pragma config ALTI2C = OFF
33:                // Tells the PIC to map I2C pins to ASDA1 and ASCL1, as opposed to
34:                // the originals - SDA1 and SCL1. Datasheet sec. 25.1
35:                
36:                #pragma config JTAGEN = OFF
37:                // Disable JTAG (we don't need it = less pins taken up). Datasheet sec. 25.1
38:                
39:                #pragma config OSCIOFNC = ON
40:                // Tell the OSC2 pin to behave as a regular digital I/O pin, instead of
41:                // exporting the internal clock signal. Datasheet sec 25.1
42:                
43:                // --------------------------------------------------------------
44:                
45:                #include "cm_uart.h"
46:                #include "cm_spi.h"
47:                #include "cm_adc.h"
48:                
49:                #include "radiohardware.h"
50:                #include "MRF24J40.h"
51:                #include "cm_radio.h"
52:                
53:                #include "cm_accelerometer.h"
54:                #include "cm_soundeffects.h"
55:                
56:                #include "cm_timing.h"
57:                
58:                #include "cm_lightmcu.h"
59:                
60:                #include "cm_ir.h"
61:                
62:                #include "Common.h"
63:                
64:                #include "HammerState.h"
65:                
66:                void blinkForever();
67:                void blinkCommandLine();
68:                
69:                void radioSenderDemo();
70:                void radioReceiverDemo();
71:                
72:                int main(int argc, char** argv) {
0042C6  FA009C     LNK #0x9C
0042C8  988F40     MOV W0, [W14+152]
0042CA  988F51     MOV W1, [W14+154]
73:                
74:                    AD1PCFGL = 0xFFFF;          // Analog? Hell naw.
0042CC  EB8200     SETM W4
0042CE  881964     MOV W4, AD1PCFGL
75:                
76:                    // Set up peripherals, devices, and state
77:                    
78:                    configureUART1();           // Set up UART1 module w/ baud 9600
0042D0  0700DD     RCALL configureUART1
79:                
80:                    uprint("\r\n ************************ BOOT UP ************************ \r\n");
0042D2  2B2B40     MOV #0xB2B4, W0
0042D4  070139     RCALL uprint
81:                
82:                    initHammerState();
0042D6  0702A6     RCALL initHammerState
83:                    HammerState *gHammerState = getHammerStatePtr();
0042D8  0702B4     RCALL getHammerStatePtr
0042DA  780200     MOV W0, W4
0042DC  780F04     MOV W4, [W14]
84:                
85:                    configureTimer1();
0042DE  07DFEE     RCALL configureTimer1
86:                    
87:                    configureRadio(0x0A00, 0x0000111111111111);
0042E0  211114     MOV #0x1111, W4
0042E2  211115     MOV #0x1111, W5
0042E4  211116     MOV #0x1111, W6
0042E6  200007     MOV #0x0, W7
0042E8  20A000     MOV #0xA00, W0
0042EA  0701AC     RCALL configureRadio
88:                
89:                    configureLightMCU_SPI();
0042EC  070317     RCALL configureLightMCU_SPI
90:                
91:                    configureADC(9);
0042EE  200090     MOV #0x9, W0
0042F0  07024C     RCALL configureADC
92:                    
93:                    //configureIRReceive();
94:                    configureIRSend();        // Not functional currently
0042F2  07FE02     RCALL configureIRSend
95:                
96:                    char out[50];
97:                    while (1) {
98:                        sendDamagePacket();
0042F4  07FE75     RCALL sendDamagePacket
99:                    }
0042F6  37FFFE     BRA 0x42F4
100:               
101:                   // This will continually print out health - which should be
102:                   // automatically responsive to IR damage/healing, if
103:                   // configureIRReceive() was called
104:                   while (1) {
105:                       uprint_dec("Health: ", gHammerState->health);
106:                   }
107:               
108:                   char doneString[50] = "DONE";
109:                   char rxbuf[50] = "DONE";
110:               
111:                   while (1) {
112:               
113:                       while (!checkSpinComplete());
114:                       resetMotionHistory();
115:               
116:                       playSound(SOUND_SPIN_COMPLETE);
117:               
118:                       gHammerState->chargeRate = 100 * exp(-0.023 * gHammerState->health);
119:                       gHammerState->charging = 1;
120:               
121:                       while (gHammerState->chargeStatus < 100) {
122:                           playSound(SOUND_CHARGING);
123:                           sendLightStateUpdate(gHammerState->health, gHammerState->chargeStatus);
124:                       }
125:               
126:                       playSound(SOUND_CHARGING_COMPLETE);
127:               
128:                       gHammerState->charging = 0;
129:                       gHammerState->chargeStatus = 0;
130:               
131:                       uprint_dec("Hammer charge status: ", gHammerState->chargeStatus);
132:               
133:                       while (!checkThrustComplete());
134:                       resetMotionHistory();
135:               
136:                       // radioSendMessage("FIRE", 0x0A00);
137:               
138:                       gHammerState->invincible = 1;
139:               
140:                       // radioGetMessage(rxbuf, 50);
141:                       uprint("Press key when cloud sends packet back... ");
142:                       uart1Rx();
143:               
144:                       if (memcmp(rxbuf, doneString, 4) != 0) {
145:                           uprint("Error, invalid packet from cloud!");
146:                           return 1;
147:                       }
148:               
149:                       gHammerState->invincible = 0;
150:               
151:                   }
152:               
153:                   return (EXIT_SUCCESS);
154:               }
155:               
156:               void setupLED() {
0042F8  FA0000     LNK #0x0
157:                   TRISAbits.TRISA2 = 0;       // Set pin RA2 to be digital output
0042FA  A942C0     BCLR TRISA, #2
158:                   PORTAbits.RA2 = 1;          // Set pin RA2 high
0042FC  A842C2     BSET PORTA, #2
159:               }
0042FE  FA8000     ULNK
004300  060000     RETURN
160:               
161:               void blinkOnce() {
004302  FA0004     LNK #0x4
162:                   PORTAbits.RA2 = 1;
004304  A842C2     BSET PORTA, #2
163:                   long i = 10000;
004306  227104     MOV #0x2710, W4
004308  200005     MOV #0x0, W5
00430A  BE8F04     MOV.D W4, [W14]
164:                   while (i--);
00430C  000000     NOP
00430E  90021E     MOV [W14+2], W4
004310  72021E     IOR W4, [W14], W4
004312  A7F004     BTSC W4, #15
004314  EA0204     NEG W4, W4
004316  EA0204     NEG W4, W4
004318  DE224F     LSR W4, #15, W4
00431A  784204     MOV.B W4, W4
00431C  EB8300     SETM W6
00431E  EB8380     SETM W7
004320  430F1E     ADD W6, [W14], [W14]
004322  4B975E     ADDC W7, [++W14], [W14--]
004324  524FE0     SUB.B W4, #0x0, [W15]
004326  3AFFF3     BRA NZ, 0x430E
165:                   PORTAbits.RA2 = 0;
004328  A942C2     BCLR PORTA, #2
166:                   i = 10000;
00432A  227104     MOV #0x2710, W4
00432C  200005     MOV #0x0, W5
00432E  BE8F04     MOV.D W4, [W14]
167:                   while (i--);
004330  000000     NOP
004332  90021E     MOV [W14+2], W4
004334  72021E     IOR W4, [W14], W4
004336  A7F004     BTSC W4, #15
004338  EA0204     NEG W4, W4
00433A  EA0204     NEG W4, W4
00433C  DE224F     LSR W4, #15, W4
00433E  784204     MOV.B W4, W4
004340  EB8300     SETM W6
004342  EB8380     SETM W7
004344  430F1E     ADD W6, [W14], [W14]
004346  4B975E     ADDC W7, [++W14], [W14--]
004348  524FE0     SUB.B W4, #0x0, [W15]
00434A  3AFFF3     BRA NZ, 0x4332
168:               }
00434C  FA8000     ULNK
00434E  060000     RETURN
169:               
170:               void radioSenderDemo() {
004350  FA0002     LNK #0x2
171:                   char rx[2];
172:                   while (1) {
173:                       uprint("Enter character to send: ");
004352  2B2F40     MOV #0xB2F4, W0
004354  0700F9     RCALL uprint
174:                       uart1_gets(rx, 1);
004356  200011     MOV #0x1, W1
004358  78000E     MOV W14, W0
00435A  0700CF     RCALL uart1_gets
175:                       radioSendMessage(rx, 0x0A00);
00435C  20A001     MOV #0xA00, W1
00435E  78000E     MOV W14, W0
004360  070189     RCALL radioSendMessage
176:                       uprint("Sent message!");
004362  2B30E0     MOV #0xB30E, W0
004364  0700F1     RCALL uprint
177:                   }
004366  37FFF5     BRA 0x4352
178:               }
179:               
180:               void radioReceiverDemo() {
004368  FA0002     LNK #0x2
181:                   char rx[2];
182:                   while (1) {
183:                       uprint("Wating for message ...");
00436A  2B31C0     MOV #0xB31C, W0
00436C  0700ED     RCALL uprint
184:               
185:                       radioGetMessage(rx, 1);
00436E  200011     MOV #0x1, W1
004370  78000E     MOV W14, W0
004372  07019B     RCALL radioGetMessage
186:               
187:                       uprint("Got message: ");
004374  2B3330     MOV #0xB333, W0
004376  0700E8     RCALL uprint
188:                       uprint(rx);
004378  78000E     MOV W14, W0
00437A  0700E6     RCALL uprint
189:               
190:                       blinkOnce();
00437C  07FFC2     RCALL blinkOnce
191:                   }
00437E  37FFF5     BRA 0x436A
192:               }
193:               
194:               void blinkForever() {
004380  FA0004     LNK #0x4
195:                   long i = 0;
004382  B82260     MUL.UU W4, #0, W4
004384  BE8F04     MOV.D W4, [W14]
196:                   while (1) {
197:                       i = 300000;
004386  293E04     MOV #0x93E0, W4
004388  200045     MOV #0x4, W5
00438A  BE8F04     MOV.D W4, [W14]
198:                       while (i--) {
00438C  000000     NOP
00438E  90021E     MOV [W14+2], W4
004390  72021E     IOR W4, [W14], W4
004392  A7F004     BTSC W4, #15
004394  EA0204     NEG W4, W4
004396  EA0204     NEG W4, W4
004398  DE224F     LSR W4, #15, W4
00439A  784204     MOV.B W4, W4
00439C  EB8300     SETM W6
00439E  EB8380     SETM W7
0043A0  430F1E     ADD W6, [W14], [W14]
0043A2  4B975E     ADDC W7, [++W14], [W14--]
0043A4  524FE0     SUB.B W4, #0x0, [W15]
0043A6  3AFFF3     BRA NZ, 0x438E
199:               
200:                       }
201:                       PORTAbits.RA2 = ~PORTAbits.RA2;
0043A8  801614     MOV PORTA, W4
0043AA  DE2242     LSR W4, #2, W4
0043AC  624261     AND.B W4, #0x1, W4
0043AE  EAC204     COM.B W4, W4
0043B0  624261     AND.B W4, #0x1, W4
0043B2  FB8204     ZE W4, W4
0043B4  620261     AND W4, #0x1, W4
0043B6  DD2242     SL W4, #2, W4
0043B8  801616     MOV PORTA, W6
0043BA  2FFFB5     MOV #0xFFFB, W5
0043BC  630285     AND W6, W5, W5
0043BE  720205     IOR W4, W5, W4
0043C0  881614     MOV W4, PORTA
202:                       uprint("Blink...");
0043C2  2B3410     MOV #0xB341, W0
0043C4  0700C1     RCALL uprint
203:                   }
0043C6  37FFDF     BRA 0x4386
204:               }
205:               
206:               void blinkCommandLine() {
0043C8  FA003C     LNK #0x3C
207:               
208:                   char rx;
209:                   char confirm_message[50];
210:                   int count = 0;
0043CA  EB0200     CLR W4
0043CC  780F04     MOV W4, [W14]
211:                   long i = 0;
0043CE  B82260     MUL.UU W4, #0, W4
0043D0  980714     MOV W4, [W14+2]
0043D2  980725     MOV W5, [W14+4]
212:                   while (1) {
213:                       // Set RA2 low
214:                       PORTAbits.RA2 = 0;
0043D4  A942C2     BCLR PORTA, #2
215:               
216:                       uprint("\r\n");
0043D6  2B34A0     MOV #0xB34A, W0
0043D8  0700B7     RCALL uprint
217:                       uprint("Please enter a number between 1 and 9: ");
0043DA  2B34D0     MOV #0xB34D, W0
0043DC  0700B5     RCALL uprint
218:               
219:                       rx = uart1Rx();
0043DE  0700A9     RCALL uart1Rx
0043E0  784200     MOV.B W0, W4
0043E2  984764     MOV.B W4, [W14+6]
220:               
221:                       int number = (int)rx - 48;
0043E4  90426E     MOV.B [W14+6], W4
0043E6  FB0204     SE W4, W4
0043E8  B10304     SUB #0x30, W4
0043EA  980744     MOV W4, [W14+8]
222:               
223:                       sprintf(confirm_message, "Blinking %d times ... ", number);
0043EC  47026A     ADD W14, #0xA, W4
0043EE  9002CE     MOV [W14+8], W5
0043F0  781F85     MOV W5, [W15++]
0043F2  2B3755     MOV #0xB375, W5
0043F4  781F85     MOV W5, [W15++]
0043F6  780004     MOV W4, W0
0043F8  07E127     RCALL __sprintf_cdnopsuxX
0043FA  5787E4     SUB W15, #0x4, W15
224:                       uprint(confirm_message);
0043FC  47026A     ADD W14, #0xA, W4
0043FE  780004     MOV W4, W0
004400  0700A3     RCALL uprint
225:               
226:                       for (count = 0; count < number; count ++) {
004402  EB0200     CLR W4
004404  780F04     MOV W4, [W14]
004406  37003D     BRA 0x4482
004480  E80F1E     INC [W14], [W14]
004482  90024E     MOV [W14+8], W4
004484  78029E     MOV [W14], W5
004486  528F84     SUB W5, W4, [W15]
004488  35FFBF     BRA LT, 0x4408
227:               
228:                           for (i = 0; i < 30000; i ++) {
004408  B82260     MUL.UU W4, #0, W4
00440A  980714     MOV W4, [W14+2]
00440C  980725     MOV W5, [W14+4]
00440E  370006     BRA 0x441C
004410  90021E     MOV [W14+2], W4
004412  9002AE     MOV [W14+4], W5
004414  420261     ADD W4, #0x1, W4
004416  4A82E0     ADDC W5, #0x0, W5
004418  980714     MOV W4, [W14+2]
00441A  980725     MOV W5, [W14+4]
00441C  90031E     MOV [W14+2], W6
00441E  9003AE     MOV [W14+4], W7
004420  2752F4     MOV #0x752F, W4
004422  200005     MOV #0x0, W5
004424  530F84     SUB W6, W4, [W15]
004426  5B8F85     SUBB W7, W5, [W15]
004428  34FFF3     BRA LE, 0x4410
229:               
230:                           }
231:               
232:                           PORTAbits.RA2 = ~PORTAbits.RA2;
00442A  801614     MOV PORTA, W4
00442C  DE2242     LSR W4, #2, W4
00442E  624261     AND.B W4, #0x1, W4
004430  EAC204     COM.B W4, W4
004432  624261     AND.B W4, #0x1, W4
004434  FB8204     ZE W4, W4
004436  620261     AND W4, #0x1, W4
004438  DD2242     SL W4, #2, W4
00443A  801616     MOV PORTA, W6
00443C  2FFFB5     MOV #0xFFFB, W5
00443E  630285     AND W6, W5, W5
004440  720205     IOR W4, W5, W4
004442  881614     MOV W4, PORTA
233:               
234:                           for (i = 0; i < 30000; i ++) {
004444  B82260     MUL.UU W4, #0, W4
004446  980714     MOV W4, [W14+2]
004448  980725     MOV W5, [W14+4]
00444A  370006     BRA 0x4458
00444C  90021E     MOV [W14+2], W4
00444E  9002AE     MOV [W14+4], W5
004450  420261     ADD W4, #0x1, W4
004452  4A82E0     ADDC W5, #0x0, W5
004454  980714     MOV W4, [W14+2]
004456  980725     MOV W5, [W14+4]
004458  90031E     MOV [W14+2], W6
00445A  9003AE     MOV [W14+4], W7
00445C  2752F4     MOV #0x752F, W4
00445E  200005     MOV #0x0, W5
004460  530F84     SUB W6, W4, [W15]
004462  5B8F85     SUBB W7, W5, [W15]
004464  34FFF3     BRA LE, 0x444C
235:               
236:                           }
237:               
238:                           PORTAbits.RA2 = ~PORTAbits.RA2;
004466  801614     MOV PORTA, W4
004468  DE2242     LSR W4, #2, W4
00446A  624261     AND.B W4, #0x1, W4
00446C  EAC204     COM.B W4, W4
00446E  624261     AND.B W4, #0x1, W4
004470  FB8204     ZE W4, W4
004472  620261     AND W4, #0x1, W4
004474  DD2242     SL W4, #2, W4
004476  801616     MOV PORTA, W6
004478  2FFFB5     MOV #0xFFFB, W5
00447A  630285     AND W6, W5, W5
00447C  720205     IOR W4, W5, W4
00447E  881614     MOV W4, PORTA
239:               
240:                       }
241:                   }
00448A  37FFA4     BRA 0x43D4
242:               }
---  C:/Users/Chase/Desktop/ecen-4013-spring2014-mchammer/src/cm_uart.c  --------------------------------
1:                 #include <stdio.h>
2:                 #include <stdlib.h>
3:                 #include <string.h>
4:                 
5:                 #include <xc.h>
6:                 
7:                 #include "cm_uart.h"
8:                 
9:                 void configureUART1() {
00448C  FA0000     LNK #0x0
10:                
11:                    // *********** PERIPHERAL PIN SELECT ***********
12:                    // Change this if needed
13:                
14:                    RPOR4bits.RP8R = 0b00011;   // Assign output U1TX to pin RP8
00448E  803645     MOV RPOR4, W5
004490  2FFE04     MOV #0xFFE0, W4
004492  628204     AND W5, W4, W4
004494  B30034     IOR #0x3, W4
004496  883644     MOV W4, RPOR4
15:                    RPINR18bits.U1RXR = 6;      // Assign input U1RX to pin RP6
004498  803525     MOV RPINR18, W5
00449A  2FFE04     MOV #0xFFE0, W4
00449C  628204     AND W5, W4, W4
00449E  B30064     IOR #0x6, W4
0044A0  883524     MOV W4, RPINR18
16:                    
17:                    // *********** PERIPHERAL PIN SELECT ***********
18:                
19:                
20:                    U1MODE = 0x00;
0044A2  EB0200     CLR W4
0044A4  881104     MOV W4, U1MODE
21:                
22:                    // U1BRG = (FCY / (16*baud)) - 1; baud = 9600
23:                
24:                    U1BRG = 23;
0044A6  200174     MOV #0x17, W4
0044A8  881144     MOV W4, U1BRG
25:                
26:                    // Enable UART1 module, and enable transmission on it
27:                
28:                    U1MODEbits.UARTEN = 1;
0044AA  A8E221     BSET 0x221, #7
29:                    U1STAbits.UTXEN = 1;
0044AC  A84223     BSET 0x223, #2
30:                }
0044AE  FA8000     ULNK
0044B0  060000     RETURN
31:                
32:                void uart1_puts(char *message) {
0044B2  FA0006     LNK #0x6
0044B4  980720     MOV W0, [W14+4]
33:                    int size = strlen(message);
0044B6  90002E     MOV [W14+4], W0
0044B8  07E0C0     RCALL _strlen
0044BA  780200     MOV W0, W4
0044BC  980714     MOV W4, [W14+2]
34:                    int i = 0;
0044BE  EB0200     CLR W4
0044C0  780F04     MOV W4, [W14]
35:                
36:                    for (i = 0; i < size; i ++) {
0044C2  EB0200     CLR W4
0044C4  780F04     MOV W4, [W14]
0044C6  370007     BRA 0x44D6
0044D4  E80F1E     INC [W14], [W14]
0044D6  90021E     MOV [W14+2], W4
0044D8  78029E     MOV [W14], W5
0044DA  528F84     SUB W5, W4, [W15]
0044DC  35FFF5     BRA LT, 0x44C8
37:                
38:                        uart1Tx(message[i]);
0044C8  78021E     MOV [W14], W4
0044CA  9002AE     MOV [W14+4], W5
0044CC  428204     ADD W5, W4, W4
0044CE  784214     MOV.B [W4], W4
0044D0  784004     MOV.B W4, W0
0044D2  070007     RCALL uart1Tx
39:                
40:                    }
41:                }
0044DE  FA8000     ULNK
0044E0  060000     RETURN
42:                
43:                void uart1Tx(char value) {
0044E2  FA0002     LNK #0x2
0044E4  784F00     MOV.B W0, [W14]
44:                    while (U1STAbits.UTXBF == 1);
0044E6  000000     NOP
0044E8  801115     MOV U1STA, W5
0044EA  202004     MOV #0x200, W4
0044EC  628204     AND W5, W4, W4
0044EE  520FE0     SUB W4, #0x0, [W15]
0044F0  3AFFFB     BRA NZ, 0x44E8
45:                    U1TXREG = value;
0044F2  FB021E     SE [W14], W4
0044F4  881124     MOV W4, U1TXREG
46:                }
0044F6  FA8000     ULNK
0044F8  060000     RETURN
47:                
48:                void uart1_gets(char *buffer, int length) {
0044FA  FA0006     LNK #0x6
0044FC  781F88     MOV W8, [W15++]
0044FE  980710     MOV W0, [W14+2]
004500  980721     MOV W1, [W14+4]
49:                    int i = 0;
004502  EB0200     CLR W4
004504  780F04     MOV W4, [W14]
50:                    for (i = 0; i < length; i ++) {
004506  EB0200     CLR W4
004508  780F04     MOV W4, [W14]
00450A  370007     BRA 0x451A
004518  E80F1E     INC [W14], [W14]
00451A  90022E     MOV [W14+4], W4
00451C  78029E     MOV [W14], W5
00451E  528F84     SUB W5, W4, [W15]
004520  35FFF5     BRA LT, 0x450C
51:                
52:                        buffer[i] = uart1Rx();
00450C  78021E     MOV [W14], W4
00450E  90029E     MOV [W14+2], W5
004510  428404     ADD W5, W4, W8
004512  07000F     RCALL uart1Rx
004514  784200     MOV.B W0, W4
004516  784C04     MOV.B W4, [W8]
53:                
54:                    }
55:                
56:                    // Make the contents of buffer a valid C string by ending
57:                    // it with the null character
58:                
59:                    buffer[i] = 0;
004522  78021E     MOV [W14], W4
004524  90029E     MOV [W14+2], W5
004526  428284     ADD W5, W4, W5
004528  EB4200     CLR.B W4
00452A  784A84     MOV.B W4, [W5]
60:                }
00452C  78044F     MOV [--W15], W8
00452E  FA8000     ULNK
004530  060000     RETURN
61:                
62:                char uart1Rx() {
004532  FA0000     LNK #0x0
63:                    while (U1STAbits.URXDA == 0);
004534  000000     NOP
004536  801114     MOV U1STA, W4
004538  620261     AND W4, #0x1, W4
00453A  520FE0     SUB W4, #0x0, [W15]
00453C  32FFFC     BRA Z, 0x4536
64:                    return U1RXREG;
00453E  801134     MOV U1RXREG, W4
004540  784204     MOV.B W4, W4
65:                }
004542  784004     MOV.B W4, W0
004544  FA8000     ULNK
004546  060000     RETURN
66:                
67:                void uprint(char *message) {
004548  FA0002     LNK #0x2
00454A  780F00     MOV W0, [W14]
68:                    uart1_puts(message);
00454C  78001E     MOV [W14], W0
00454E  07FFB1     RCALL uart1_puts
69:                    uart1_puts("\r\n");
004550  2B40E0     MOV #0xB40E, W0
004552  07FFAF     RCALL uart1_puts
70:                }
004554  FA8000     ULNK
004556  060000     RETURN
71:                
72:                void uprint_int(char *message, int value) {
004558  FA000A     LNK #0xA
00455A  BE9F88     MOV.D W8, [W15++]
00455C  980730     MOV W0, [W14+6]
00455E  980741     MOV W1, [W14+8]
004562  78020F     MOV W15, W4
004564  780484     MOV W4, W9
73:                
74:                    int size = strlen(message);
004566  90003E     MOV [W14+6], W0
004568  07E068     RCALL _strlen
00456A  780200     MOV W0, W4
00456C  780F04     MOV W4, [W14]
75:                    char buf[size + 10];
00456E  78029E     MOV [W14], W5
004570  42826A     ADD W5, #0xA, W4
004572  E90284     DEC W4, W5
004574  980715     MOV W5, [W14+2]
004576  E80204     INC W4, W4
004578  E80204     INC W4, W4
00457A  D10204     LSR W4, W4
00457C  420284     ADD W4, W4, W5
00457E  78020F     MOV W15, W4
004580  478785     ADD W15, W5, W15
004582  E80204     INC W4, W4
004584  D10204     LSR W4, W4
004586  420204     ADD W4, W4, W4
004588  980724     MOV W4, [W14+4]
76:                    sprintf(buf, "%s%d\r\n", message, value);
00458A  90022E     MOV [W14+4], W4
00458C  9002CE     MOV [W14+8], W5
00458E  781F85     MOV W5, [W15++]
004590  9002BE     MOV [W14+6], W5
004592  781F85     MOV W5, [W15++]
004594  2B4115     MOV #0xB411, W5
004596  781F85     MOV W5, [W15++]
004598  780004     MOV W4, W0
00459A  07E056     RCALL __sprintf_cdnopsuxX
00459C  5787E6     SUB W15, #0x6, W15
77:                    uprint(buf);
00459E  90022E     MOV [W14+4], W4
0045A0  780004     MOV W4, W0
0045A2  07FFD2     RCALL uprint
0045A4  780789     MOV W9, W15
78:                
79:                }
004560  78040F     MOV W15, W8
0045A6  780788     MOV W8, W15
0045A8  BE044F     MOV.D [--W15], W8
0045AA  FA8000     ULNK
0045AC  060000     RETURN
80:                
81:                void uprint_dec(char *message, double value) {
0045AE  FA000C     LNK #0xC
0045B0  BE9F88     MOV.D W8, [W15++]
0045B2  980730     MOV W0, [W14+6]
0045B4  980742     MOV W2, [W14+8]
0045B6  980753     MOV W3, [W14+10]
0045BA  78020F     MOV W15, W4
0045BC  780484     MOV W4, W9
82:                
83:                    int size = strlen(message);
0045BE  90003E     MOV [W14+6], W0
0045C0  07E03C     RCALL _strlen
0045C2  780200     MOV W0, W4
0045C4  780F04     MOV W4, [W14]
84:                    char buf[size + 10];
0045C6  78029E     MOV [W14], W5
0045C8  42826A     ADD W5, #0xA, W4
0045CA  E90284     DEC W4, W5
0045CC  980715     MOV W5, [W14+2]
0045CE  E80204     INC W4, W4
0045D0  E80204     INC W4, W4
0045D2  D10204     LSR W4, W4
0045D4  420284     ADD W4, W4, W5
0045D6  78020F     MOV W15, W4
0045D8  478785     ADD W15, W5, W15
0045DA  E80204     INC W4, W4
0045DC  D10204     LSR W4, W4
0045DE  420204     ADD W4, W4, W4
0045E0  980724     MOV W4, [W14+4]
85:                    sprintf(buf, "%s%.3f\r\n", message, value);
0045E2  90032E     MOV [W14+4], W6
0045E4  90024E     MOV [W14+8], W4
0045E6  9002DE     MOV [W14+10], W5
0045E8  BE9F84     MOV.D W4, [W15++]
0045EA  90023E     MOV [W14+6], W4
0045EC  781F84     MOV W4, [W15++]
0045EE  2B4184     MOV #0xB418, W4
0045F0  781F84     MOV W4, [W15++]
0045F2  780006     MOV W6, W0
0045F4  07E029     RCALL __sprintf_cdnopsuxX
0045F6  5787E8     SUB W15, #0x8, W15
86:                    uprint(buf);
0045F8  90022E     MOV [W14+4], W4
0045FA  780004     MOV W4, W0
0045FC  07FFA5     RCALL uprint
0045FE  780789     MOV W9, W15
87:                
88:                }
0045B8  78040F     MOV W15, W8
004600  780788     MOV W8, W15
004602  BE044F     MOV.D [--W15], W8
004604  FA8000     ULNK
004606  060000     RETURN
---  C:/Users/Chase/Desktop/ecen-4013-spring2014-mchammer/src/cm_timing.c  ------------------------------
1:                 #include <stdlib.h>
2:                 #include <xc.h>
3:                 
4:                 #include "cm_timing.h"
5:                 
6:                 #include "HammerState.h"
7:                 
8:                 #include "MRF24J40.h"
9:                 
10:                #define DELTA_T (1.0 / 1600.0)
11:                
12:                int countMod2;
13:                
14:                void __attribute__((__interrupt__, no_auto_psv)) _T1Interrupt(void) {
00029A  F80036     PUSH RCOUNT
00029C  BE9F80     MOV.D W0, [W15++]
00029E  BE9F82     MOV.D W2, [W15++]
0002A0  BE9F84     MOV.D W4, [W15++]
0002A2  BE9F86     MOV.D W6, [W15++]
0002A4  FA0000     LNK #0x0
15:                
16:                    // Should be generated at 1600 Hz = (FCY / 256 / 9)
17:                
18:                    // Do all stuff that happens on an interval!
19:                    
20:                    HammerState_doCharge(DELTA_T);
0002A6  2D70A0     MOV #0xD70A, W0
0002A8  23A231     MOV #0x3A23, W1
0002AA  0722D0     RCALL HammerState_doCharge
21:                
22:                    IFS0bits.T1IF = 0;  // Clear Timer1 Interrupt Flag
0002AC  A96084     BCLR IFS0, #3
23:                }
0002AE  FA8000     ULNK
0002B0  BE034F     MOV.D [--W15], W6
0002B2  BE024F     MOV.D [--W15], W4
0002B4  BE014F     MOV.D [--W15], W2
0002B6  BE004F     MOV.D [--W15], W0
0002B8  F90036     POP RCOUNT
0002BA  064000     RETFIE
24:                
25:                void configureTimer1() {
0002BC  FA0000     LNK #0x0
26:                
27:                    // Configure Timer1 to generate an interrupt at 1600 Hz
28:                
29:                    T1CONbits.TON = 0;          // Disable Timer
0002BE  A9E105     BCLR 0x105, #7
30:                    T1CONbits.TCS = 0;          // Select internal instruction cycle clock
0002C0  A92104     BCLR T1CON, #1
31:                    T1CONbits.TGATE = 0;        // Disable Gated Timer mode
0002C2  A9C104     BCLR T1CON, #6
32:                    T1CONbits.TCKPS = 0b11;     // Select 1:256 Prescaler
0002C4  800824     MOV T1CON, W4
0002C6  A04004     BSET W4, #4
0002C8  A05004     BSET W4, #5
0002CA  880824     MOV W4, T1CON
33:                    TMR1 = 0x00;                // Clear timer register
0002CC  EB0200     CLR W4
0002CE  880804     MOV W4, TMR1
34:                    PR1 = 9;                    // Load the period value
0002D0  200094     MOV #0x9, W4
0002D2  880814     MOV W4, PR1
35:                    IPC0bits.T1IP = 0x01;       // Set Timer1 Interrupt Priority Level
0002D4  800524     MOV IPC0, W4
0002D6  A0C004     BSET W4, #12
0002D8  A1D004     BCLR W4, #13
0002DA  A1E004     BCLR W4, #14
0002DC  880524     MOV W4, IPC0
36:                    IFS0bits.T1IF = 0;          // Clear Timer1 Interrupt Flag
0002DE  A96084     BCLR IFS0, #3
37:                    IEC0bits.T1IE = 1;          // Enable Timer1 interrupt
0002E0  A86094     BSET IEC0, #3
38:                    T1CONbits.TON = 1;          // Start Timer
0002E2  A8E105     BSET 0x105, #7
39:                
40:                    countMod2 = 0;
0002E4  EB0200     CLR W4
0002E6  88F084     MOV W4, countMod2
41:                }
0002E8  FA8000     ULNK
0002EA  060000     RETURN
---  C:/Users/Chase/Desktop/ecen-4013-spring2014-mchammer/src/cm_spi.c  ---------------------------------
1:                 #include <stdlib.h>
2:                 #include <string.h>
3:                 
4:                 #include <xc.h>
5:                 
6:                 #include "cm_spi.h"
7:                 #include "cm_uart.h"
8:                 
9:                 void configureSPI1Master() {
0046EC  FA0000     LNK #0x0
10:                
11:                    // *********** PERIPHERAL PIN SELECT ***********
12:                    // Change this if needed
13:                
14:                    RPOR0bits.RP0R = 0b00111;       // Set output SDO1 to RP0
0046EE  803605     MOV RPOR0, W5
0046F0  2FFE04     MOV #0xFFE0, W4
0046F2  628204     AND W5, W4, W4
0046F4  B30074     IOR #0x7, W4
0046F6  883604     MOV W4, RPOR0
15:                    RPOR0bits.RP1R = 0b01000;       // Set output SCK1 to RP1
0046F8  803605     MOV RPOR0, W5
0046FA  2E0FF4     MOV #0xE0FF, W4
0046FC  628284     AND W5, W4, W5
0046FE  208004     MOV #0x800, W4
004700  720205     IOR W4, W5, W4
004702  883604     MOV W4, RPOR0
16:                    RPOR1bits.RP2R = 0b01001;       // Set output SS1 to RP2
004704  803615     MOV RPOR1, W5
004706  2FFE04     MOV #0xFFE0, W4
004708  628204     AND W5, W4, W4
00470A  B30094     IOR #0x9, W4
00470C  883614     MOV W4, RPOR1
17:                
18:                    // *********** PERIPHERAL PIN SELECT ***********
19:                
20:                    // SPI1CON1 Register Settings
21:                    SPI1CON1bits.DISSCK = 0;    //Internal Serial Clock is Enabled
00470E  A98243     BCLR 0x243, #4
22:                    SPI1CON1bits.DISSDO = 0;    //SDOx pin is controlled by the module
004710  A96243     BCLR 0x243, #3
23:                    SPI1CON1bits.MODE16 = 1;    //Communication is word-wide (16 bits)
004712  A84243     BSET 0x243, #2
24:                    SPI1CON1bits.SMP = 0;       //Input Data is sampled at the middle of data output time
004714  A92243     BCLR 0x243, #1
25:                    SPI1CON1bits.CKE = 0;       //Serial output data changes on transition from
004716  A90243     BCLR 0x243, #0
26:                
27:                    SPI1CON1bits.CKP = 0;       //Idle state for clock is a low level;
004718  A9C242     BCLR SPI1CON1, #6
28:                
29:                    SPI1CON1bits.MSTEN = 1;     //Master Mode Enabled
00471A  A8A242     BSET SPI1CON1, #5
30:                    SPI1STATbits.SPIEN = 1;     //Enable SPI Module
00471C  A8E241     BSET 0x241, #7
31:                }
00471E  FA8000     ULNK
004720  060000     RETURN
32:                
33:                void configureSPI1Slave() {
004722  FA0000     LNK #0x0
34:                
35:                    // *********** PERIPHERAL PIN SELECT ***********
36:                    // Change this if needed
37:                
38:                    RPINR20bits.SDI1R = 3;          // Set input SDI1 to RA3
004724  803545     MOV RPINR20, W5
004726  2FFE04     MOV #0xFFE0, W4
004728  628204     AND W5, W4, W4
00472A  B30034     IOR #0x3, W4
00472C  883544     MOV W4, RPINR20
39:                    RPINR20bits.SCK1R = 4;          // Set input SCK1 to RA4
00472E  803545     MOV RPINR20, W5
004730  2E0FF4     MOV #0xE0FF, W4
004732  628284     AND W5, W4, W5
004734  204004     MOV #0x400, W4
004736  720205     IOR W4, W5, W4
004738  883544     MOV W4, RPINR20
40:                    RPINR21bits.SS1R = 5;           // Set intput SS1 to RA5
00473A  803555     MOV RPINR21, W5
00473C  2FFE04     MOV #0xFFE0, W4
00473E  628204     AND W5, W4, W4
004740  B30054     IOR #0x5, W4
004742  883554     MOV W4, RPINR21
41:                
42:                    // *********** PERIPHERAL PIN SELECT ***********
43:                
44:                    SPI1BUF = 0;
004744  EB0200     CLR W4
004746  881244     MOV W4, SPI1BUF
45:                
46:                    // SPI1CON1 Register Settings
47:                    SPI1CON1bits.DISSCK = 0;    //Internal Serial Clock is Enabled
004748  A98243     BCLR 0x243, #4
48:                    SPI1CON1bits.DISSDO = 1;    //SDOx pin is unused by the module
00474A  A86243     BSET 0x243, #3
49:                    SPI1CON1bits.MODE16 = 1;    //Communication is word-wide (16 bits)
00474C  A84243     BSET 0x243, #2
50:                    SPI1CON1bits.SMP = 0;       //Input Data is sampled at the middle of data
00474E  A92243     BCLR 0x243, #1
51:                    SPI1CON1bits.SSEN = 0;
004750  A9E242     BCLR SPI1CON1, #7
52:                
53:                    SPI1CON1bits.CKE = 0;       //Serial output data changes on transition
004752  A90243     BCLR 0x243, #0
54:                
55:                    SPI1CON1bits.CKP = 0;       //Idle state for clock is a low level; active
004754  A9C242     BCLR SPI1CON1, #6
56:                
57:                    SPI1CON1bits.MSTEN = 0;     //Master Mode disabled
004756  A9A242     BCLR SPI1CON1, #5
58:                    SPI1STATbits.SPIROV = 0;    //No Receive Overflow has Occurred
004758  A9C240     BCLR SPI1STAT, #6
59:                    SPI1STATbits.SPIEN = 1;     //Enable SPI Module
00475A  A8E241     BSET 0x241, #7
60:                }
00475C  FA8000     ULNK
00475E  060000     RETURN
61:                
62:                void spi1Tx(int data) {
004760  FA0002     LNK #0x2
004762  780F00     MOV W0, [W14]
63:                
64:                    while (SPI1STATbits.SPITBF);
004764  000000     NOP
004766  801204     MOV SPI1STAT, W4
004768  620262     AND W4, #0x2, W4
00476A  520FE0     SUB W4, #0x0, [W15]
00476C  3AFFFC     BRA NZ, 0x4766
65:                    SPI1BUF = data;
00476E  78021E     MOV [W14], W4
004770  881244     MOV W4, SPI1BUF
66:                
67:                }
004772  FA8000     ULNK
004774  060000     RETURN
68:                
69:                int spi1Rx() {
004776  FA0000     LNK #0x0
70:                
71:                    while (SPI1STATbits.SPIRBF == 0);
004778  000000     NOP
00477A  801204     MOV SPI1STAT, W4
00477C  620261     AND W4, #0x1, W4
00477E  520FE0     SUB W4, #0x0, [W15]
004780  32FFFC     BRA Z, 0x477A
72:                    return SPI1BUF;
004782  801244     MOV SPI1BUF, W4
73:                
74:                }
004784  780004     MOV W4, W0
004786  FA8000     ULNK
004788  060000     RETURN
---  C:/Users/Chase/Desktop/ecen-4013-spring2014-mchammer/src/cm_soundeffects.c  ------------------------
1:                 #include <stdlib.h>
2:                 #include <xc.h>
3:                 
4:                 #include "cm_uart.h"
5:                 #include "cm_soundeffects.h"
6:                 
7:                 int playSound(SoundEffect s) {
004932  FA0002     LNK #0x2
004934  780F00     MOV W0, [W14]
8:                 
9:                     // Nonblocking
10:                
11:                    uprint("Playing some sound... ");
004936  2B3F60     MOV #0xB3F6, W0
004938  07FE07     RCALL uprint
12:                
13:                    return 1;
00493A  200014     MOV #0x1, W4
14:                
15:                }
00493C  780004     MOV W4, W0
00493E  FA8000     ULNK
004940  060000     RETURN
---  C:/Users/Chase/Desktop/ecen-4013-spring2014-mchammer/src/cm_radio.c  -------------------------------
1:                 #include <stdlib.h>
2:                 #include <string.h>
3:                 #include <stdio.h>
4:                 #include <xc.h>
5:                 
6:                 #include "cm_uart.h"
7:                 #include "cm_radio.h"
8:                 
9:                 #include "radiohardware.h"
10:                #include "MRF24J40.h"
11:                
12:                typedef struct {
13:                	WORD	txCnt;				// Counter incremented by sender
14:                	UINT8	data[50];			// Dummy data payload. Make sure to keep sizeof(DATA_PAYLOAD)<=TX_PAYLOAD_SIZE
15:                }DATA_PAYLOAD;
16:                
17:                static DATA_PAYLOAD txPayload;	// Structure with data to send.
18:                
19:                void RadioInitP2P(void)
20:                // Initialize the tx packet. This only needs to be done once if the framecontrol and dest address isn't
21:                // changed - as here.
22:                {
004608  FA0000     LNK #0x0
23:                	Tx.frameControl.frameType = PACKET_TYPE_DATA;
00460A  A81FBA     BSET 0x1FBA, #0
00460C  A93FBA     BCLR 0x1FBA, #1
00460E  A95FBA     BCLR 0x1FBA, #2
24:                	Tx.frameControl.securityEnabled = 0;
004610  A97FBA     BCLR 0x1FBA, #3
25:                	Tx.frameControl.framePending = 0;
004612  A99FBA     BCLR 0x1FBA, #4
26:                	Tx.frameControl.ackRequest = 1;
004614  A8BFBA     BSET 0x1FBA, #5
27:                	Tx.frameControl.panIDcomp = 1;
004616  A8DFBA     BSET 0x1FBA, #6
28:                	Tx.frameControl.dstAddrMode = SHORT_ADDR_FIELD;
004618  A95FBB     BCLR 0x1FBB, #2
00461A  A87FBB     BSET 0x1FBB, #3
29:                	Tx.frameControl.frameVersion = 0;
00461C  A99FBB     BCLR 0x1FBB, #4
00461E  A9BFBB     BCLR 0x1FBB, #5
30:                	Tx.frameControl.srcAddrMode = NO_ADDR_FIELD;
004620  A9DFBB     BCLR 0x1FBB, #6
004622  A9FFBB     BCLR 0x1FBB, #7
31:                	Tx.dstPANID = RadioStatus.MyPANID;
004624  80F414     MOV 0x1E82, W4
004626  88FDF4     MOV W4, 0x1FBE
32:                	Tx.dstAddr = RadioStatus.MyShortAddress;		// Both nodes for this demo uses the same addresses.
004628  80F3C4     MOV 0x1E78, W4
00462A  200005     MOV #0x0, W5
00462C  200006     MOV #0x0, W6
00462E  200007     MOV #0x0, W7
004630  21FC00     MOV #0x1FC0, W0
004632  BE9804     MOV.D W4, [W0++]
004634  BE9006     MOV.D W6, [W0--]
33:                	Tx.payload = (BYTE*)&txPayload;
004636  21E3E4     MOV #0x1E3E, W4
004638  88FEA4     MOV W4, 0x1FD4
34:                	Tx.payloadLength=sizeof(DATA_PAYLOAD);
00463A  B3C344     MOV.B #0x34, W4
00463C  780004     MOV W4, W0
00463E  B7FFD2     MOV.B WREG, 0x1FD2
35:                }
004640  FA8000     ULNK
004642  060000     RETURN
36:                
37:                int configureRadio(int short_addr, long long long_addr) {
004644  FA000C     LNK #0xC
004646  980710     MOV W0, [W14+2]
004648  980724     MOV W4, [W14+4]
00464A  980735     MOV W5, [W14+6]
00464C  980746     MOV W6, [W14+8]
00464E  980757     MOV W7, [W14+10]
38:                
39:                    // *********** PERIPHERAL PIN SELECT ***********
40:                    //
41:                    // The driver code mandates that the PPS and other settings be handled
42:                    // in radiohardware.h/radiohardware.c - so this is where PPS settings 
43:                    // should be changed if needed
44:                    //
45:                    // *********** PERIPHERAL PIN SELECT ***********
46:                
47:                    RadioHW_Init();
004650  07012F     RCALL RadioHW_Init
48:                
49:                    int radiostatus = RadioInit();
004652  07F87B     RCALL RadioInit
004654  780200     MOV W0, W4
004656  780F04     MOV W4, [W14]
50:                    RadioInitP2P();
004658  07FFD7     RCALL RadioInitP2P
51:                
52:                    // Set the short address, long address, and pan ID
53:                    // (I think they can be pretty much anything except the reserved
54:                    // MAC addresses (0's and F's)
55:                    RadioSetAddress(short_addr, long_addr, 0x0F00);
00465A  90022E     MOV [W14+4], W4
00465C  9002BE     MOV [W14+6], W5
00465E  90034E     MOV [W14+8], W6
004660  9003DE     MOV [W14+10], W7
004662  90001E     MOV [W14+2], W0
004664  20F001     MOV #0xF00, W1
004666  07F897     RCALL RadioSetAddress
56:                
57:                    // Between 11 and 26
58:                    RadioSetChannel(11);
004668  B3C0B0     MOV.B #0xB, W0
00466A  07F8D1     RCALL RadioSetChannel
59:                
60:                    return radiostatus;
00466C  78021E     MOV [W14], W4
61:                
62:                }
00466E  780004     MOV W4, W0
004670  FA8000     ULNK
004672  060000     RETURN
63:                
64:                void radioSendMessage(char *message, int dest_short_addr) {
004674  FA0004     LNK #0x4
004676  780F00     MOV W0, [W14]
004678  980711     MOV W1, [W14+2]
65:                
66:                    Tx.payloadLength = sprintf((char *)Tx.payload, message);
00467A  80FEA4     MOV 0x1FD4, W4
00467C  781F9E     MOV [W14], [W15++]
00467E  780004     MOV W4, W0
004680  07DFC6     RCALL _sprintf
004682  E9878F     DEC2 W15, W15
004684  780200     MOV W0, W4
004686  784204     MOV.B W4, W4
004688  780004     MOV W4, W0
00468A  B7FFD2     MOV.B WREG, 0x1FD2
67:                    Tx.dstAddr = (UINT16)dest_short_addr;
00468C  90021E     MOV [W14+2], W4
00468E  200005     MOV #0x0, W5
004690  200006     MOV #0x0, W6
004692  200007     MOV #0x0, W7
004694  21FC00     MOV #0x1FC0, W0
004696  BE9804     MOV.D W4, [W0++]
004698  BE9006     MOV.D W6, [W0--]
68:                
69:                    RadioTXPacket();
00469A  07F9B1     RCALL RadioTXPacket
70:                
71:                    // Blocks until send complete
72:                
73:                    while (RadioStatus.TX_BUSY);
00469C  000000     NOP
00469E  80F394     MOV RadioStatus, W4
0046A0  620261     AND W4, #0x1, W4
0046A2  520FE0     SUB W4, #0x0, [W15]
0046A4  3AFFFC     BRA NZ, 0x469E
74:                    
75:                }
0046A6  FA8000     ULNK
0046A8  060000     RETURN
76:                
77:                void radioGetMessage(char *buf, int length) {
0046AA  FA0004     LNK #0x4
0046AC  780F00     MOV W0, [W14]
0046AE  980711     MOV W1, [W14+2]
78:                
79:                    while (RadioRXPacket() == 0);           // Block until packet received
0046B0  000000     NOP
0046B2  07FA0A     RCALL RadioRXPacket
0046B4  784200     MOV.B W0, W4
0046B6  524FE0     SUB.B W4, #0x0, [W15]
0046B8  32FFFC     BRA Z, 0x46B2
80:                
81:                    if (Rx.payloadLength > length) {
0046BA  21FF24     MOV #0x1FF2, W4
0046BC  784214     MOV.B [W4], W4
0046BE  FB8284     ZE W4, W5
0046C0  90021E     MOV [W14+2], W4
0046C2  528F84     SUB W5, W4, [W15]
0046C4  340004     BRA LE, 0x46CE
82:                        Rx.payloadLength = length;
0046C6  90021E     MOV [W14+2], W4
0046C8  784204     MOV.B W4, W4
0046CA  780004     MOV W4, W0
0046CC  B7FFF2     MOV.B WREG, 0x1FF2
83:                    }
84:                
85:                    Rx.payload[Rx.payloadLength] = 0;
0046CE  80FFA5     MOV 0x1FF4, W5
0046D0  21FF24     MOV #0x1FF2, W4
0046D2  784214     MOV.B [W4], W4
0046D4  FB8204     ZE W4, W4
0046D6  428284     ADD W5, W4, W5
0046D8  EB4200     CLR.B W4
0046DA  784A84     MOV.B W4, [W5]
86:                    sprintf(buf, (char *)Rx.payload);
0046DC  80FFA4     MOV 0x1FF4, W4
0046DE  781F84     MOV W4, [W15++]
0046E0  78001E     MOV [W14], W0
0046E2  07DF95     RCALL _sprintf
0046E4  E9878F     DEC2 W15, W15
87:                
88:                    RadioDiscardPacket();
0046E6  07FAD7     RCALL RadioDiscardPacket
89:                
90:                }
0046E8  FA8000     ULNK
0046EA  060000     RETURN
---  C:/Users/Chase/Desktop/ecen-4013-spring2014-mchammer/src/cm_lightmcu.c  ----------------------------
1:                 #include <stdlib.h>
2:                 #include <math.h>
3:                 
4:                 #include <xc.h>
5:                 
6:                 #include "cm_lightmcu.h"
7:                 #include "cm_uart.h"
8:                 
9:                 void configureLightMCU_SPI() {
00491C  FA0000     LNK #0x0
10:                
11:                }
00491E  FA8000     ULNK
004920  060000     RETURN
12:                
13:                void sendLightStateUpdate(double health, double charge) {
004922  FA0008     LNK #0x8
004924  BE8F00     MOV.D W0, [W14]
004926  980722     MOV W2, [W14+4]
004928  980733     MOV W3, [W14+6]
14:                
15:                    uprint("Sending update to light co-processor");
00492A  2B3D00     MOV #0xB3D0, W0
00492C  07FE0D     RCALL uprint
16:                
17:                }
00492E  FA8000     ULNK
004930  060000     RETURN
---  C:/Users/Chase/Desktop/ecen-4013-spring2014-mchammer/src/cm_ir.c  ----------------------------------
1:                 #include <stdio.h>
2:                 #include <stdlib.h>
3:                 
4:                 #include <xc.h>
5:                 
6:                 #include "cm_uart.h"
7:                 #include "cm_ir.h"
8:                 #include "HammerState.h"
9:                 
10:                #include "Common.h"
11:                
12:                #define IN_RANGE(x, a, b)       ((x >= a) && (x <= b))
13:                
14:                unsigned int c1, c2;
15:                unsigned int diff;
16:                int inPacket;
17:                int dCounter, hCounter;
18:                
19:                #define LED_PIN_TRIS    TRISBbits.TRISB5
20:                #define LED_PIN_PORT    PORTBbits.RB5
21:                
22:                // Private functions
23:                void sendCycles(int n);
24:                void offCycles(int n);
25:                
26:                void configureIRReceive() {
003DF6  FA0000     LNK #0x0
27:                
28:                    T2CON = 0x8000;             // 1:1 prescale, Timer 2 on
003DF8  280004     MOV #0x8000, W4
003DFA  880884     MOV W4, T2CON
29:                
30:                    TRISBbits.TRISB4 = 1;       // Set pin RB4 as input
003DFC  A882C8     BSET TRISB, #4
31:                    RPINR7bits.IC1R = 4;        // Set input IC1 to pin RP4
003DFE  803475     MOV RPINR7, W5
003E00  2FFE04     MOV #0xFFE0, W4
003E02  628204     AND W5, W4, W4
003E04  A02004     BSET W4, #2
003E06  883474     MOV W4, RPINR7
32:                
33:                    IC1CONbits.ICM = 0b00;      // Disable Input Capture 1 module
003E08  800A14     MOV IC1CON, W4
003E0A  A10004     BCLR W4, #0
003E0C  A11004     BCLR W4, #1
003E0E  A12004     BCLR W4, #2
003E10  880A14     MOV W4, IC1CON
34:                    IC1CONbits.ICTMR = 1;       // Select Timer2 as the IC1 Time base
003E12  A8E142     BSET IC1CON, #7
35:                    IC1CONbits.ICI = 0b01;      // Interrupt on every second capture event
003E14  800A14     MOV IC1CON, W4
003E16  A05004     BSET W4, #5
003E18  A16004     BCLR W4, #6
003E1A  880A14     MOV W4, IC1CON
36:                    IC1CONbits.ICM = 0b001;     // Re-enable / Generate capture event every edge
003E1C  800A14     MOV IC1CON, W4
003E1E  A00004     BSET W4, #0
003E20  A11004     BCLR W4, #1
003E22  A12004     BCLR W4, #2
003E24  880A14     MOV W4, IC1CON
37:                
38:                    // Enable Capture Interrupt And Timer2
39:                    IPC0bits.IC1IP = 1;         // Setup IC1 interrupt priority level
003E26  800524     MOV IPC0, W4
003E28  A04004     BSET W4, #4
003E2A  A15004     BCLR W4, #5
003E2C  A16004     BCLR W4, #6
003E2E  880524     MOV W4, IPC0
40:                    IFS0bits.IC1IF = 0;         // Clear IC1 Interrupt Status Flag
003E30  A92084     BCLR IFS0, #1
41:                    IEC0bits.IC1IE = 1;         // Enable IC1 interrupt
003E32  A82094     BSET IEC0, #1
42:                
43:                    inPacket = 0;
003E34  EB0200     CLR W4
003E36  88F184     MOV W4, inPacket
44:                    dCounter = 0;
003E38  EB0200     CLR W4
003E3A  88F194     MOV W4, dCounter
45:                    hCounter = 0;
003E3C  EB0200     CLR W4
003E3E  88F1A4     MOV W4, hCounter
46:                    
47:                
48:                }
003E40  FA8000     ULNK
003E42  060000     RETURN
49:                
50:                void __attribute__ ((__interrupt__,no_auto_psv)) _IC1Interrupt(void)
51:                {
003E44  F80036     PUSH RCOUNT
003E46  BE9F80     MOV.D W0, [W15++]
003E48  BE9F82     MOV.D W2, [W15++]
003E4A  BE9F84     MOV.D W4, [W15++]
003E4C  BE9F86     MOV.D W6, [W15++]
003E4E  781F88     MOV W8, [W15++]
003E50  FA0000     LNK #0x0
52:                
53:                    IFS0bits.IC1IF = 0; // Reset respective interrupt flag
003E52  A92084     BCLR IFS0, #1
54:                
55:                    if (!inPacket) {
003E54  80F184     MOV inPacket, W4
003E56  520FE0     SUB W4, #0x0, [W15]
003E58  3A0005     BRA NZ, 0x3E64
56:                        c1 = IC1BUF;
003E5A  800A04     MOV IC1BUF, W4
003E5C  88F154     MOV W4, c1
57:                        inPacket = 1;
003E5E  200014     MOV #0x1, W4
003E60  88F184     MOV W4, inPacket
003E62  370004     BRA 0x3E6C
58:                    } else {
59:                        c2 = IC1BUF;
003E64  800A04     MOV IC1BUF, W4
003E66  88F164     MOV W4, c2
60:                        inPacket = 0;
003E68  EB0200     CLR W4
003E6A  88F184     MOV W4, inPacket
61:                    }
62:                
63:                    if (!inPacket) {
003E6C  80F184     MOV inPacket, W4
003E6E  520FE0     SUB W4, #0x0, [W15]
003E70  3A001B     BRA NZ, 0x3EA8
64:                        diff = c2 - c1;
003E72  80F165     MOV c2, W5
003E74  80F154     MOV c1, W4
003E76  528204     SUB W5, W4, W4
003E78  88F174     MOV W4, diff
65:                        if ((diff > 1350) && (diff < 1750)) {
003E7A  80F175     MOV diff, W5
003E7C  205464     MOV #0x546, W4
003E7E  528F84     SUB W5, W4, [W15]
003E80  360008     BRA LEU, 0x3E92
003E82  80F175     MOV diff, W5
003E84  206D54     MOV #0x6D5, W4
003E86  528F84     SUB W5, W4, [W15]
003E88  3E0004     BRA GTU, 0x3E92
66:                            dCounter ++;
003E8A  80F194     MOV dCounter, W4
003E8C  E80204     INC W4, W4
003E8E  88F194     MOV W4, dCounter
003E90  37000B     BRA 0x3EA8
67:                        } else if ((diff > 2000) && (diff < 2400)) {
003E92  80F175     MOV diff, W5
003E94  207D04     MOV #0x7D0, W4
003E96  528F84     SUB W5, W4, [W15]
003E98  360007     BRA LEU, 0x3EA8
003E9A  80F175     MOV diff, W5
003E9C  2095F4     MOV #0x95F, W4
003E9E  528F84     SUB W5, W4, [W15]
003EA0  3E0003     BRA GTU, 0x3EA8
68:                            hCounter ++;
003EA2  80F1A4     MOV hCounter, W4
003EA4  E80204     INC W4, W4
003EA6  88F1A4     MOV W4, hCounter
69:                        }
70:                    }
71:                
72:                    if (dCounter == 2) {
003EA8  80F194     MOV dCounter, W4
003EAA  520FE2     SUB W4, #0x2, [W15]
003EAC  3A000D     BRA NZ, 0x3EC8
73:                        dCounter = 0;
003EAE  EB0200     CLR W4
003EB0  88F194     MOV W4, dCounter
74:                        getHammerStatePtr()->health = getHammerStatePtr()->health - 1;
003EB2  0704C7     RCALL getHammerStatePtr
003EB4  780400     MOV W0, W8
003EB6  0704C5     RCALL getHammerStatePtr
003EB8  780200     MOV W0, W4
003EBA  BE0214     MOV.D [W4], W4
003EBC  200002     MOV #0x0, W2
003EBE  23F803     MOV #0x3F80, W3
003EC0  BE0004     MOV.D W4, W0
003EC2  07E246     RCALL ___subsf3
003EC4  BE0200     MOV.D W0, W4
003EC6  BE8C04     MOV.D W4, [W8]
75:                    }
76:                
77:                    if (hCounter == 2) {
003EC8  80F1A4     MOV hCounter, W4
003ECA  520FE2     SUB W4, #0x2, [W15]
003ECC  3A000D     BRA NZ, 0x3EE8
78:                        hCounter = 0;
003ECE  EB0200     CLR W4
003ED0  88F1A4     MOV W4, hCounter
79:                        getHammerStatePtr()->health = getHammerStatePtr()->health + 1;
003ED2  0704B7     RCALL getHammerStatePtr
003ED4  780400     MOV W0, W8
003ED6  0704B5     RCALL getHammerStatePtr
003ED8  780200     MOV W0, W4
003EDA  BE0214     MOV.D [W4], W4
003EDC  200002     MOV #0x0, W2
003EDE  23F803     MOV #0x3F80, W3
003EE0  BE0004     MOV.D W4, W0
003EE2  07E237     RCALL ___addsf3
003EE4  BE0200     MOV.D W0, W4
003EE6  BE8C04     MOV.D W4, [W8]
80:                    }
81:                }
003EE8  FA8000     ULNK
003EEA  78044F     MOV [--W15], W8
003EEC  BE034F     MOV.D [--W15], W6
003EEE  BE024F     MOV.D [--W15], W4
003EF0  BE014F     MOV.D [--W15], W2
003EF2  BE004F     MOV.D [--W15], W0
003EF4  F90036     POP RCOUNT
003EF6  064000     RETFIE
82:                
83:                // **********************************************************************
84:                
85:                
86:                #define TQ_START    10
87:                #define TQ_DAMAGE   20
88:                #define TQ_HEAL     30
89:                #define TQ_STOP     150
90:                
91:                
92:                int sendCount;
93:                
94:                int toggle, val, sent;
95:                
96:                void configureIRSend() {
003EF8  FA0000     LNK #0x0
97:                
98:                    TRISBbits.TRISB5 = 0;
003EFA  A9A2C8     BCLR TRISB, #5
99:                    PORTBbits.RB5 = 0;
003EFC  A9A2CA     BCLR PORTB, #5
100:               
101:               //    RPOR2bits.RP5R = 0b10010;   // Output OC1 to pin RP5
102:               
103:               //    OC1CON = 0;                 // It is a good practice to clear off the control bits initially
104:               //    OC1CONbits.OCTSEL = 0;      // Timer2 is source
105:               //
106:               //    OC1R = 33;
107:               //    OC1RS = 66;
108:               
109:                   T2CON = 0;
003EFE  EB0200     CLR W4
003F00  880884     MOV W4, T2CON
110:                   T2CONbits.TCKPS = 0b00;
003F02  800884     MOV T2CON, W4
003F04  A14004     BCLR W4, #4
003F06  A15004     BCLR W4, #5
003F08  880884     MOV W4, T2CON
111:                   T2CONbits.TCS = 0;
003F0A  A92110     BCLR T2CON, #1
112:                   PR2 = 33;
003F0C  200214     MOV #0x21, W4
003F0E  880864     MOV W4, PR2
113:                   T2CONbits.TON = 1;
003F10  A8E111     BSET 0x111, #7
114:               
115:               //    OC1CONbits.OCM = 0b000;         // Off for now
116:               
117:               //    IPC0bits.OC1IP = 1;         // Setup OC1 interrupt priority level
118:               //    IFS0bits.OC1IF = 0;         // Clear OC1 Interrupt Status Flag
119:               //    IEC0bits.OC1IE = 1;         // Enable OC1 interrupt
120:               
121:                   IPC1bits.T2IP = 1;
003F12  800534     MOV IPC1, W4
003F14  A0C004     BSET W4, #12
003F16  A1D004     BCLR W4, #13
003F18  A1E004     BCLR W4, #14
003F1A  880534     MOV W4, IPC1
122:                   IFS0bits.T2IF = 0;
003F1C  A9E084     BCLR IFS0, #7
123:                   IEC0bits.T2IE = 0;
003F1E  A9E094     BCLR IEC0, #7
124:               
125:                   sendCount = 0;
003F20  EB0200     CLR W4
003F22  88F1B4     MOV W4, sendCount
126:               
127:                   toggle = 0;
003F24  EB0200     CLR W4
003F26  88F1C4     MOV W4, toggle
128:               
129:               }
003F28  FA8000     ULNK
003F2A  060000     RETURN
130:               
131:               void __attribute__((__interrupt__, no_auto_psv)) _T2Interrupt(void) {
003F2C  781F80     MOV W0, [W15++]
003F2E  BE9F84     MOV.D W4, [W15++]
003F30  781F86     MOV W6, [W15++]
003F32  FA0000     LNK #0x0
132:               
133:                   IFS0bits.T2IF = 0;
003F34  A9E084     BCLR IFS0, #7
134:               
135:                   if (sendCount < TQ_START) {
003F36  80F1B4     MOV sendCount, W4
003F38  520FE9     SUB W4, #0x9, [W15]
003F3A  3C0003     BRA GT, 0x3F42
136:                       val = 1;
003F3C  200014     MOV #0x1, W4
003F3E  88F1D4     MOV W4, val
003F40  370033     BRA 0x3FA8
137:                   } else if (sendCount < 150) {
003F42  80F1B5     MOV sendCount, W5
003F44  200954     MOV #0x95, W4
003F46  528F84     SUB W5, W4, [W15]
003F48  3C0003     BRA GT, 0x3F50
138:                       val = 0;
003F4A  EB0200     CLR W4
003F4C  88F1D4     MOV W4, val
003F4E  37002C     BRA 0x3FA8
139:                   } else if (sendCount < (150 + TQ_DAMAGE)) {
003F50  80F1B5     MOV sendCount, W5
003F52  200A94     MOV #0xA9, W4
003F54  528F84     SUB W5, W4, [W15]
003F56  3C0003     BRA GT, 0x3F5E
140:                       val = 1;
003F58  200014     MOV #0x1, W4
003F5A  88F1D4     MOV W4, val
003F5C  370025     BRA 0x3FA8
141:                   } else if (sendCount < 300) {
003F5E  80F1B5     MOV sendCount, W5
003F60  2012B4     MOV #0x12B, W4
003F62  528F84     SUB W5, W4, [W15]
003F64  3C0003     BRA GT, 0x3F6C
142:                       val = 0;
003F66  EB0200     CLR W4
003F68  88F1D4     MOV W4, val
003F6A  37001E     BRA 0x3FA8
143:                   } else if (sendCount < (300 + TQ_DAMAGE)) {
003F6C  80F1B5     MOV sendCount, W5
003F6E  2013F4     MOV #0x13F, W4
003F70  528F84     SUB W5, W4, [W15]
003F72  3C0003     BRA GT, 0x3F7A
144:                       val = 1;
003F74  200014     MOV #0x1, W4
003F76  88F1D4     MOV W4, val
003F78  370017     BRA 0x3FA8
145:                   } else if (sendCount < 450) {
003F7A  80F1B5     MOV sendCount, W5
003F7C  201C14     MOV #0x1C1, W4
003F7E  528F84     SUB W5, W4, [W15]
003F80  3C0003     BRA GT, 0x3F88
146:                       val = 0;
003F82  EB0200     CLR W4
003F84  88F1D4     MOV W4, val
003F86  370010     BRA 0x3FA8
147:                   } else if (sendCount < (450 + TQ_STOP)) {
003F88  80F1B5     MOV sendCount, W5
003F8A  202574     MOV #0x257, W4
003F8C  528F84     SUB W5, W4, [W15]
003F8E  3C0003     BRA GT, 0x3F96
148:                       val = 1;
003F90  200014     MOV #0x1, W4
003F92  88F1D4     MOV W4, val
003F94  370009     BRA 0x3FA8
149:                   } else if (sendCount < 1200) {
003F96  80F1B5     MOV sendCount, W5
003F98  204AF4     MOV #0x4AF, W4
003F9A  528F84     SUB W5, W4, [W15]
003F9C  3C0003     BRA GT, 0x3FA4
150:                       val = 0;
003F9E  EB0200     CLR W4
003FA0  88F1D4     MOV W4, val
003FA2  370002     BRA 0x3FA8
151:                   } else {
152:                       sent = 1;
003FA4  200014     MOV #0x1, W4
003FA6  88F1E4     MOV W4, sent
153:                   }
154:               
155:                   if (!toggle) {
003FA8  80F1C4     MOV toggle, W4
003FAA  520FE0     SUB W4, #0x0, [W15]
003FAC  3A000E     BRA NZ, 0x3FCA
156:                       PORTBbits.RB5 = val;
003FAE  80F1D4     MOV val, W4
003FB0  784204     MOV.B W4, W4
003FB2  624261     AND.B W4, #0x1, W4
003FB4  FB8204     ZE W4, W4
003FB6  620261     AND W4, #0x1, W4
003FB8  DD2245     SL W4, #5, W4
003FBA  801656     MOV PORTB, W6
003FBC  2FFDF5     MOV #0xFFDF, W5
003FBE  630285     AND W6, W5, W5
003FC0  720205     IOR W4, W5, W4
003FC2  881654     MOV W4, PORTB
157:                       toggle = 1;
003FC4  200014     MOV #0x1, W4
003FC6  88F1C4     MOV W4, toggle
003FC8  370006     BRA 0x3FD6
158:                   } else {
159:                       PORTBbits.RB5 = 0;
003FCA  A9A2CA     BCLR PORTB, #5
160:                       toggle = 0;
003FCC  EB0200     CLR W4
003FCE  88F1C4     MOV W4, toggle
161:                       sendCount ++;
003FD0  80F1B4     MOV sendCount, W4
003FD2  E80204     INC W4, W4
003FD4  88F1B4     MOV W4, sendCount
162:                   }
163:               
164:               }
003FD6  FA8000     ULNK
003FD8  78034F     MOV [--W15], W6
003FDA  BE024F     MOV.D [--W15], W4
003FDC  78004F     MOV [--W15], W0
003FDE  064000     RETFIE
165:               
166:               void sendDamagePacket() {
003FE0  FA0000     LNK #0x0
167:               
168:                   INT_OFF();
003FE2  070448     RCALL INT_OFF
169:               
170:                   sent = 0;
003FE4  EB0200     CLR W4
003FE6  88F1E4     MOV W4, sent
171:                   sendCount = 0;
003FE8  EB0200     CLR W4
003FEA  88F1B4     MOV W4, sendCount
172:                   toggle = 0;
003FEC  EB0200     CLR W4
003FEE  88F1C4     MOV W4, toggle
173:                   IEC0bits.T2IE = 1;
003FF0  A8E094     BSET IEC0, #7
174:               
175:                   while (!sent);
003FF2  000000     NOP
003FF4  80F1E4     MOV sent, W4
003FF6  520FE0     SUB W4, #0x0, [W15]
003FF8  32FFFD     BRA Z, 0x3FF4
176:               
177:                   INT_ON();
003FFA  07044F     RCALL INT_ON
178:               
179:               }
003FFC  FA8000     ULNK
003FFE  060000     RETURN
180:               
181:               void sendHealPacket() {
004000  FA0000     LNK #0x0
182:                   
183:               }
004002  FA8000     ULNK
004004  060000     RETURN
184:               
185:               void pulseLED()
186:               {
004006  FA0000     LNK #0x0
187:                   LED_PIN_PORT = 1;      // turn on IR
004008  A8A2CA     BSET PORTB, #5
188:                   DELAY_US(8.82);
00400A  200180     MOV #0x18, W0
00400C  200001     MOV #0x0, W1
00400E  070478     RCALL ___delay32
189:               
190:                   LED_PIN_PORT = 0;     // turn off IR
004010  A9A2CA     BCLR PORTB, #5
191:                   DELAY_US(8.82);
004012  200180     MOV #0x18, W0
004014  200001     MOV #0x0, W1
004016  070474     RCALL ___delay32
192:               }
004018  FA8000     ULNK
00401A  060000     RETURN
193:               
194:               void sendCycles(int n) {
00401C  FA0004     LNK #0x4
00401E  980710     MOV W0, [W14+2]
195:                   int i = n;
004020  90021E     MOV [W14+2], W4
004022  780F04     MOV W4, [W14]
196:                   while (i--) pulseLED();
004024  370001     BRA 0x4028
004026  07FFEF     RCALL pulseLED
004028  78021E     MOV [W14], W4
00402A  A7F004     BTSC W4, #15
00402C  EA0204     NEG W4, W4
00402E  EA0204     NEG W4, W4
004030  DE224F     LSR W4, #15, W4
004032  784204     MOV.B W4, W4
004034  E90F1E     DEC [W14], [W14]
004036  524FE0     SUB.B W4, #0x0, [W15]
004038  3AFFF6     BRA NZ, 0x4026
197:               }
00403A  FA8000     ULNK
00403C  060000     RETURN
198:               
199:               void offCycles(int n) {
00403E  FA0004     LNK #0x4
004040  980710     MOV W0, [W14+2]
200:                   int i = n;
004042  90021E     MOV [W14+2], W4
004044  780F04     MOV W4, [W14]
201:                   while (i--) DELAY_US(8.82*2);
004046  370003     BRA 0x404E
004048  200300     MOV #0x30, W0
00404A  200001     MOV #0x0, W1
00404C  070459     RCALL ___delay32
00404E  78021E     MOV [W14], W4
004050  A7F004     BTSC W4, #15
004052  EA0204     NEG W4, W4
004054  EA0204     NEG W4, W4
004056  DE224F     LSR W4, #15, W4
004058  784204     MOV.B W4, W4
00405A  E90F1E     DEC [W14], [W14]
00405C  524FE0     SUB.B W4, #0x0, [W15]
00405E  3AFFF4     BRA NZ, 0x4048
202:               }
004060  FA8000     ULNK
004062  060000     RETURN
---  C:/Users/Chase/Desktop/ecen-4013-spring2014-mchammer/src/cm_adc.c  ---------------------------------
1:                 #include <stdlib.h>
2:                 #include <xc.h>
3:                 
4:                 #include "cm_adc.h"
5:                 
6:                 void configureADC(int analogport) {
00478A  FA0002     LNK #0x2
00478C  780F00     MOV W0, [W14]
7:                     AD1CON1bits.AD12B = 1;              // 12-bit one-channel higher acc. mode
00478E  A84321     BSET 0x321, #2
8:                     AD1CON2bits.VCFG = 0;               // AVdd and AVss as + and - ref
004790  801914     MOV AD1CON2, W4
004792  A1D004     BCLR W4, #13
004794  A1E004     BCLR W4, #14
004796  A1F004     BCLR W4, #15
004798  881914     MOV W4, AD1CON2
9:                     AD1CON3bits.ADCS = 0;               // T_AD = T_CY (sounds about right)
00479A  EB4200     CLR.B W4
00479C  780004     MOV W4, W0
00479E  B7E324     MOV.B WREG, AD1CON3
10:                
11:                    AD1PCFGL = AD1PCFGL & (~(1 << analogport));      // Disable digital function on pin 'analogport'; make it analog
0047A0  200015     MOV #0x1, W5
0047A2  78021E     MOV [W14], W4
0047A4  DD2A04     SL W5, W4, W4
0047A6  EA8204     COM W4, W4
0047A8  780284     MOV W4, W5
0047AA  801964     MOV AD1PCFGL, W4
0047AC  628204     AND W5, W4, W4
0047AE  881964     MOV W4, AD1PCFGL
12:                
13:                    AD1CHS0bits.CH0SA = analogport;     // Sample on analog pin 'analogport'
0047B0  78021E     MOV [W14], W4
0047B2  784204     MOV.B W4, W4
0047B4  62427F     AND.B W4, #0x1F, W4
0047B6  FB8204     ZE W4, W4
0047B8  62027F     AND W4, #0x1F, W4
0047BA  801946     MOV AD1CHS0, W6
0047BC  2FFE05     MOV #0xFFE0, W5
0047BE  630285     AND W6, W5, W5
0047C0  720205     IOR W4, W5, W4
0047C2  881944     MOV W4, AD1CHS0
14:                    AD1CON2bits.CHPS = 0;               // Convert "channel 0"
0047C4  801914     MOV AD1CON2, W4
0047C6  A18004     BCLR W4, #8
0047C8  A19004     BCLR W4, #9
0047CA  881914     MOV W4, AD1CON2
15:                
16:                    AD1CON1bits.FORM = 0;               // Read buffer in integer form
0047CC  801904     MOV AD1CON1, W4
0047CE  A18004     BCLR W4, #8
0047D0  A19004     BCLR W4, #9
0047D2  881904     MOV W4, AD1CON1
17:                
18:                    AD1CON1bits.ASAM = 0;               // Don't auto sample, manually set the SAMP bit to sample
0047D4  A94320     BCLR AD1CON1, #2
19:                    AD1CON1bits.SSRC = 0b111;           // Auto convert (conversion is ended when the module decides)
0047D6  801904     MOV AD1CON1, W4
0047D8  A05004     BSET W4, #5
0047DA  A06004     BSET W4, #6
0047DC  A07004     BSET W4, #7
0047DE  881904     MOV W4, AD1CON1
20:                
21:                    AD1CON1bits.ADON = 1;               // Enable module
0047E0  A8E321     BSET 0x321, #7
22:                }
0047E2  FA8000     ULNK
0047E4  060000     RETURN
23:                
24:                unsigned int readADCRaw() {
0047E6  FA0000     LNK #0x0
25:                    AD1CON1bits.SAMP = 1;
0047E8  A82320     BSET AD1CON1, #1
26:                    while (!AD1CON1bits.DONE);
0047EA  000000     NOP
0047EC  801904     MOV AD1CON1, W4
0047EE  620261     AND W4, #0x1, W4
0047F0  520FE0     SUB W4, #0x0, [W15]
0047F2  32FFFC     BRA Z, 0x47EC
27:                    return ADC1BUF0;
0047F4  801804     MOV ADC1BUF0, W4
28:                }
0047F6  780004     MOV W4, W0
0047F8  FA8000     ULNK
0047FA  060000     RETURN
29:                
30:                double readADCPercent() {
0047FC  FA0000     LNK #0x0
31:                    return 100 * (readADCRaw() / 4096.0);
0047FE  07FFF3     RCALL readADCRaw
004800  780200     MOV W0, W4
004802  200005     MOV #0x0, W5
004804  BE0004     MOV.D W4, W0
004806  07DE44     RCALL ___floatunsisf
004808  BE0200     MOV.D W0, W4
00480A  200002     MOV #0x0, W2
00480C  245803     MOV #0x4580, W3
00480E  BE0004     MOV.D W4, W0
004810  07DDFD     RCALL ___divsf3
004812  BE0200     MOV.D W0, W4
004814  200002     MOV #0x0, W2
004816  242C83     MOV #0x42C8, W3
004818  BE0004     MOV.D W4, W0
00481A  07DE7A     RCALL ___mulsf3
00481C  BE0200     MOV.D W0, W4
32:                }
00481E  BE0004     MOV.D W4, W0
004820  FA8000     ULNK
004822  060000     RETURN
---  C:/Users/Chase/Desktop/ecen-4013-spring2014-mchammer/src/cm_accelerometer.c  -----------------------
1:                 #include <stdlib.h>
2:                 #include <xc.h>
3:                 
4:                 #include "cm_uart.h"
5:                 #include "cm_adc.h"
6:                 
7:                 int checkSpinComplete() {
0048DA  FA0000     LNK #0x0
8:                     
9:                     uprint("Press key when spin is complete: ");
0048DC  2B38C0     MOV #0xB38C, W0
0048DE  07FE34     RCALL uprint
10:                    uart1Rx();
0048E0  07FE28     RCALL uart1Rx
11:                
12:                    return 1;
0048E2  200014     MOV #0x1, W4
13:                
14:                }
0048E4  780004     MOV W4, W0
0048E6  FA8000     ULNK
0048E8  060000     RETURN
15:                
16:                int checkThrustComplete() {
0048EA  FA0000     LNK #0x0
17:                
18:                    uprint("Press key when thrust complete: ");
0048EC  2B3AE0     MOV #0xB3AE, W0
0048EE  07FE2C     RCALL uprint
19:                    uart1Rx();
0048F0  07FE20     RCALL uart1Rx
20:                
21:                    return 1;
0048F2  200014     MOV #0x1, W4
22:                
23:                }
0048F4  780004     MOV W4, W0
0048F6  FA8000     ULNK
0048F8  060000     RETURN
24:                
25:                void resetMotionHistory() {
0048FA  FA0000     LNK #0x0
26:                    
27:                }
0048FC  FA8000     ULNK
0048FE  060000     RETURN
---  C:/Users/Chase/Desktop/ecen-4013-spring2014-mchammer/src/MRF24J40.c  -------------------------------
1:                 /* Driver for Microchip MRF24J40 802.15.4 radio hardware
2:                  * New parts (c) 2010-2012 nerdfever.com
3:                  * Originally based on Microchip MiWi DE v.3.1.3, 5/28/2010 (c) Microchip
4:                  * Modified for PIC24 and mplabC30 by Ruben Jnsson 2012.
5:                 */
6:                 
7:                 #define _IN_MRF24J40_
8:                 
9:                 #include <string.h>		// memset()
10:                #include "radiohardware.h"
11:                #include "MRF24J40.h"
12:                #include "radioaddress.h"	// addr for radio
13:                #include "cm_uart.h"
14:                
15:                // globals
16:                
17:                MRF24J40_STATUS volatile RadioStatus;				// radio state
18:                UINT8 volatile RXBuffer[PACKET_BUFFERS][RX_BUFFER_SIZE];	// rx packet buffers 
19:                PACKET Tx, Rx;							// structures describing transmitted and received packets
20:                static UINT64	MRF24J40Timer=0;
21:                
22:                // Call this from a timer interrupt every 256us.
23:                // Used for timeouts
24:                void MRF24J40_Timer(void)
25:                {
003422  FA0000     LNK #0x0
26:                	MRF24J40Timer++;	
003424  21FF84     MOV #0x1FF8, W4
003426  BE0034     MOV.D [W4++], W0
003428  BE0124     MOV.D [W4--], W2
00342A  200014     MOV #0x1, W4
00342C  200005     MOV #0x0, W5
00342E  B83360     MUL.UU W6, #0, W6
003430  420200     ADD W4, W0, W4
003432  4A8281     ADDC W5, W1, W5
003434  4B0302     ADDC W6, W2, W6
003436  4B8383     ADDC W7, W3, W7
003438  21FF80     MOV #0x1FF8, W0
00343A  BE9804     MOV.D W4, [W0++]
00343C  BE9006     MOV.D W6, [W0--]
27:                }	
00343E  FA8000     ULNK
003440  060000     RETURN
28:                
29:                UINT64 timerTicksSince(UINT64 savedTimer)
30:                {	
003442  FA0008     LNK #0x8
003444  BE9F00     MOV.D W0, [W14++]
003446  BE9702     MOV.D W2, [W14--]
31:                	return MRF24J40Timer-savedTimer;
003448  21FF84     MOV #0x1FF8, W4
00344A  BE0034     MOV.D [W4++], W0
00344C  BE0124     MOV.D [W4--], W2
00344E  BE023E     MOV.D [W14++], W4
003450  BE032E     MOV.D [W14--], W6
003452  500204     SUB W0, W4, W4
003454  588285     SUBB W1, W5, W5
003456  590306     SUBB W2, W6, W6
003458  598387     SUBB W3, W7, W7
32:                }	
00345A  BE0004     MOV.D W4, W0
00345C  BE0106     MOV.D W6, W2
00345E  FA8000     ULNK
003460  060000     RETURN
33:                	
34:                // this combines memcpy with incrementing the source point.  It copies bytewise, allowing it to copy to/from unaligned addresses
35:                unsigned char* readBytes(unsigned char* dstPtr, unsigned char* srcPtr, unsigned int count)
36:                {
003462  FA0006     LNK #0x6
003464  780F00     MOV W0, [W14]
003466  980711     MOV W1, [W14+2]
003468  980722     MOV W2, [W14+4]
37:                	while(count--){
00346A  370008     BRA 0x347C
00347C  90022E     MOV [W14+4], W4
00347E  A7F004     BTSC W4, #15
003480  EA0204     NEG W4, W4
003482  EA0204     NEG W4, W4
003484  DE224F     LSR W4, #15, W4
003486  784204     MOV.B W4, W4
003488  9002AE     MOV [W14+4], W5
00348A  E90285     DEC W5, W5
00348C  980725     MOV W5, [W14+4]
00348E  524FE0     SUB.B W4, #0x0, [W15]
003490  3AFFED     BRA NZ, 0x346C
38:                		*dstPtr++ = *srcPtr++;
00346C  90021E     MOV [W14+2], W4
00346E  784214     MOV.B [W4], W4
003470  78029E     MOV [W14], W5
003472  784A84     MOV.B W4, [W5]
003474  E80F1E     INC [W14], [W14]
003476  90021E     MOV [W14+2], W4
003478  E80204     INC W4, W4
00347A  980714     MOV W4, [W14+2]
39:                	}	
40:                
41:                	return srcPtr;
003492  90021E     MOV [W14+2], W4
42:                }
003494  780004     MOV W4, W0
003496  FA8000     ULNK
003498  060000     RETURN
43:                
44:                /* The key to understanding SPI is that there is only 1 clock line, and so all transfers
45:                   are always bidirectional - you send one bit for each you receive and vice-versa.  And the CLK
46:                   only runs (in Master mode) when you transmit.
47:                
48:                   So to transmit, you store to the TX buffer, wait for it to clock out, flush away the bogus received byte.
49:                
50:                   And to receive, you send, wait for the byte to clock in, then read it.
51:                
52:                */
53:                
54:                void spiPut(unsigned char v)		// write 1 byte to SPI
55:                {
00349A  FA0004     LNK #0x4
00349C  984720     MOV.B W0, [W14+2]
56:                    int i;
57:                
58:                    #ifdef HARDWARE_SPI
59:                
60:                    while (SPI1STATbits.SPITBF);
61:                    SPI1BUF = v;
62:                    int i = 40;
63:                    while (i--);
64:                    
65:                    #else
66:                    RADIO_SPI_SCK = 0;
00349E  A962C2     BCLR PORTA, #3
67:                
68:                    for(i = 0; i < 8; i++) {
0034A0  EB0200     CLR W4
0034A2  780F04     MOV W4, [W14]
0034A4  370012     BRA 0x34CA
0034C8  E80F1E     INC [W14], [W14]
0034CA  78021E     MOV [W14], W4
0034CC  520FE7     SUB W4, #0x7, [W15]
0034CE  34FFEB     BRA LE, 0x34A6
69:                        RADIO_SPI_SDO = (v >> (7-i));
0034A6  90422E     MOV.B [W14+2], W4
0034A8  FB8284     ZE W4, W5
0034AA  200076     MOV #0x7, W6
0034AC  53021E     SUB W6, [W14], W4
0034AE  DEAA04     ASR W5, W4, W4
0034B0  784204     MOV.B W4, W4
0034B2  624261     AND.B W4, #0x1, W4
0034B4  FB8204     ZE W4, W4
0034B6  620261     AND W4, #0x1, W4
0034B8  DD2242     SL W4, #2, W4
0034BA  801656     MOV PORTB, W6
0034BC  2FFFB5     MOV #0xFFFB, W5
0034BE  630285     AND W6, W5, W5
0034C0  720205     IOR W4, W5, W4
0034C2  881654     MOV W4, PORTB
70:                        RADIO_SPI_SCK = 1;
0034C4  A862C2     BSET PORTA, #3
71:                        RADIO_SPI_SCK = 0;
0034C6  A962C2     BCLR PORTA, #3
72:                    }
73:                    #endif
74:                }
0034D0  FA8000     ULNK
0034D2  060000     RETURN
75:                
76:                unsigned char spiGet(void)		// read 1 byte from SPI
77:                {
0034D4  FA0002     LNK #0x2
78:                    #ifdef HARDWARE_SPI
79:                
80:                    while (SPI1STATbits.SPIRBF == 0);
81:                    unsigned char v = SPI1BUF;
82:                    int i = 40;
83:                    while (i--);
84:                
85:                    return v;
86:                
87:                    #else
88:                    unsigned char i;
89:                    unsigned char spidata = 0;
0034D6  EB4200     CLR.B W4
0034D8  984714     MOV.B W4, [W14+1]
90:                
91:                    RADIO_SPI_SDO = 0;
0034DA  A942CA     BCLR PORTB, #2
92:                    RADIO_SPI_SCK = 0;
0034DC  A962C2     BCLR PORTA, #3
93:                
94:                    for(i = 0; i < 8; i++){
0034DE  EB4200     CLR.B W4
0034E0  784F04     MOV.B W4, [W14]
0034E2  37000C     BRA 0x34FC
0034FA  E84F1E     INC.B [W14], [W14]
0034FC  78421E     MOV.B [W14], W4
0034FE  524FE7     SUB.B W4, #0x7, [W15]
003500  36FFF1     BRA LEU, 0x34E4
95:                        spidata = (spidata << 1) | RADIO_SPI_SDI;
0034E4  90421E     MOV.B [W14+1], W4
0034E6  FB8204     ZE W4, W4
0034E8  420204     ADD W4, W4, W4
0034EA  784284     MOV.B W4, W5
0034EC  801654     MOV PORTB, W4
0034EE  DE2243     LSR W4, #3, W4
0034F0  624261     AND.B W4, #0x1, W4
0034F2  72C204     IOR.B W5, W4, W4
0034F4  984714     MOV.B W4, [W14+1]
96:                        RADIO_SPI_SCK = 1;
0034F6  A862C2     BSET PORTA, #3
97:                        RADIO_SPI_SCK = 0;
0034F8  A962C2     BCLR PORTA, #3
98:                    }
99:                
100:                   return spidata;
003502  90421E     MOV.B [W14+1], W4
101:                   #endif
102:               }
003504  784004     MOV.B W4, W0
003506  FA8000     ULNK
003508  060000     RETURN
103:               
104:               // reads byte from radio at long "address"
105:               UINT8 highRead(UINT16 address)
106:               {
00350A  FA0004     LNK #0x4
00350C  980710     MOV W0, [W14+2]
107:               	UINT8 toReturn;
108:               
109:               	UINT8 tmpRADIO_IE = RADIO_IE;
00350E  8004B4     MOV IEC1, W4
003510  DE2244     LSR W4, #4, W4
003512  624261     AND.B W4, #0x1, W4
003514  784F04     MOV.B W4, [W14]
110:               
111:               	RADIO_IE = 0;
003516  A98096     BCLR IEC1, #4
112:               	RADIO_CS = 0;
003518  A9A2CB     BCLR 0x2CB, #5
113:               	spiPut(((address>>3)&0x7F)|0x80);
00351A  90021E     MOV [W14+2], W4
00351C  DE2243     LSR W4, #3, W4
00351E  784284     MOV.B W4, W5
003520  B3C804     MOV.B #0x80, W4
003522  72C204     IOR.B W5, W4, W4
003524  784004     MOV.B W4, W0
003526  07FFB9     RCALL spiPut
114:               	spiPut(((address<<5)&0xE0));
003528  90021E     MOV [W14+2], W4
00352A  784204     MOV.B W4, W4
00352C  200055     MOV #0x5, W5
00352E  DD2205     SL W4, W5, W4
003530  784004     MOV.B W4, W0
003532  07FFB3     RCALL spiPut
115:               	toReturn = spiGet();
003534  07FFCF     RCALL spiGet
003536  784200     MOV.B W0, W4
003538  984714     MOV.B W4, [W14+1]
116:               	RADIO_CS = 1;
00353A  A8A2CB     BSET 0x2CB, #5
117:               	RADIO_IE = tmpRADIO_IE;
00353C  78429E     MOV.B [W14], W5
00353E  62C261     AND.B W5, #0x1, W4
003540  FB8204     ZE W4, W4
003542  620261     AND W4, #0x1, W4
003544  DD2244     SL W4, #4, W4
003546  8004B6     MOV IEC1, W6
003548  2FFEF5     MOV #0xFFEF, W5
00354A  630285     AND W6, W5, W5
00354C  720205     IOR W4, W5, W4
00354E  8804B4     MOV W4, IEC1
118:               
119:               	return toReturn;
003550  90421E     MOV.B [W14+1], W4
120:               }
003552  784004     MOV.B W4, W0
003554  FA8000     ULNK
003556  060000     RETURN
121:               
122:               // writes "value" to radio at long "address"
123:               void highWrite(UINT16 address, UINT8 value)
124:               {
003558  FA0006     LNK #0x6
00355A  980710     MOV W0, [W14+2]
00355C  984741     MOV.B W1, [W14+4]
125:               	UINT8 tmpRADIO_IE = RADIO_IE;
00355E  8004B4     MOV IEC1, W4
003560  DE2244     LSR W4, #4, W4
003562  624261     AND.B W4, #0x1, W4
003564  784F04     MOV.B W4, [W14]
126:               
127:               	RADIO_IE = 0;					// disable radio ints during communication
003566  A98096     BCLR IEC1, #4
128:               	RADIO_CS = 0;					// select radio SPI bus
003568  A9A2CB     BCLR 0x2CB, #5
129:               	spiPut((((UINT8)(address>>3))&0x7F)|0x80);
00356A  90021E     MOV [W14+2], W4
00356C  DE2243     LSR W4, #3, W4
00356E  784284     MOV.B W4, W5
003570  B3C804     MOV.B #0x80, W4
003572  72C204     IOR.B W5, W4, W4
003574  784004     MOV.B W4, W0
003576  07FF91     RCALL spiPut
130:               	spiPut((((UINT8)(address<<5))&0xE0)|0x10);
003578  90021E     MOV [W14+2], W4
00357A  784204     MOV.B W4, W4
00357C  200055     MOV #0x5, W5
00357E  DD2205     SL W4, W5, W4
003580  A04404     BSET.B W4, #4
003582  784004     MOV.B W4, W0
003584  07FF8A     RCALL spiPut
131:               	spiPut(value);
003586  90404E     MOV.B [W14+4], W0
003588  07FF88     RCALL spiPut
132:               	RADIO_CS = 1;					// de-select radio SPI bus
00358A  A8A2CB     BSET 0x2CB, #5
133:               	RADIO_IE = tmpRADIO_IE;                         // restore interrupt state
00358C  78429E     MOV.B [W14], W5
00358E  62C261     AND.B W5, #0x1, W4
003590  FB8204     ZE W4, W4
003592  620261     AND W4, #0x1, W4
003594  DD2244     SL W4, #4, W4
003596  8004B6     MOV IEC1, W6
003598  2FFEF5     MOV #0xFFEF, W5
00359A  630285     AND W6, W5, W5
00359C  720205     IOR W4, W5, W4
00359E  8804B4     MOV W4, IEC1
134:               }
0035A0  FA8000     ULNK
0035A2  060000     RETURN
135:               
136:               // reads byte from radio at short "address"
137:               UINT8 lowRead(UINT8 address)
138:               {
0035A4  FA0004     LNK #0x4
0035A6  984720     MOV.B W0, [W14+2]
139:               	UINT8 toReturn;
140:               	UINT8 tmpRADIO_IE = RADIO_IE;
0035A8  8004B4     MOV IEC1, W4
0035AA  DE2244     LSR W4, #4, W4
0035AC  624261     AND.B W4, #0x1, W4
0035AE  784F04     MOV.B W4, [W14]
141:               
142:               	RADIO_IE = 0;					// disable radio ints during communication
0035B0  A98096     BCLR IEC1, #4
143:               	RADIO_CS = 0;					// select radio SPI bus
0035B2  A9A2CB     BCLR 0x2CB, #5
144:               	spiPut(address);
0035B4  90402E     MOV.B [W14+2], W0
0035B6  07FF71     RCALL spiPut
145:               	toReturn = spiGet();
0035B8  07FF8D     RCALL spiGet
0035BA  784200     MOV.B W0, W4
0035BC  984714     MOV.B W4, [W14+1]
146:               	RADIO_CS = 1;					// de-select radio SPI bus
0035BE  A8A2CB     BSET 0x2CB, #5
147:               	RADIO_IE = tmpRADIO_IE;                         // restore interrupt state
0035C0  78429E     MOV.B [W14], W5
0035C2  62C261     AND.B W5, #0x1, W4
0035C4  FB8204     ZE W4, W4
0035C6  620261     AND W4, #0x1, W4
0035C8  DD2244     SL W4, #4, W4
0035CA  8004B6     MOV IEC1, W6
0035CC  2FFEF5     MOV #0xFFEF, W5
0035CE  630285     AND W6, W5, W5
0035D0  720205     IOR W4, W5, W4
0035D2  8804B4     MOV W4, IEC1
148:               	return toReturn;
0035D4  90421E     MOV.B [W14+1], W4
149:               }
0035D6  784004     MOV.B W4, W0
0035D8  FA8000     ULNK
0035DA  060000     RETURN
150:               
151:               // writes "value" to radio at short "address"
152:               void lowWrite(UINT8 address, UINT8 value)
153:               {
0035DC  FA0004     LNK #0x4
0035DE  984720     MOV.B W0, [W14+2]
0035E0  984731     MOV.B W1, [W14+3]
154:               	UINT8 tmpRADIO_IE = RADIO_IE;
0035E2  8004B4     MOV IEC1, W4
0035E4  DE2244     LSR W4, #4, W4
0035E6  624261     AND.B W4, #0x1, W4
0035E8  784F04     MOV.B W4, [W14]
155:               
156:               	RADIO_IE = 0;
0035EA  A98096     BCLR IEC1, #4
157:               	RADIO_CS = 0;
0035EC  A9A2CB     BCLR 0x2CB, #5
158:               	spiPut(address);
0035EE  90402E     MOV.B [W14+2], W0
0035F0  07FF54     RCALL spiPut
159:               	spiPut(value);
0035F2  90403E     MOV.B [W14+3], W0
0035F4  07FF52     RCALL spiPut
160:               	RADIO_CS = 1;
0035F6  A8A2CB     BSET 0x2CB, #5
161:               	RADIO_IE = tmpRADIO_IE;
0035F8  78429E     MOV.B [W14], W5
0035FA  62C261     AND.B W5, #0x1, W4
0035FC  FB8204     ZE W4, W4
0035FE  620261     AND W4, #0x1, W4
003600  DD2244     SL W4, #4, W4
003602  8004B6     MOV IEC1, W6
003604  2FFEF5     MOV #0xFFEF, W5
003606  630285     AND W6, W5, W5
003608  720205     IOR W4, W5, W4
00360A  8804B4     MOV W4, IEC1
162:               }
00360C  FA8000     ULNK
00360E  060000     RETURN
163:               
164:               // writes count consecutive bytes from source into consecutive FIFO slots starting at "register".  Returns next empty register #.
165:               UINT8 toTXfifo(UINT16 reg, UINT8* source, UINT8 count)
166:               {
003610  FA0006     LNK #0x6
003612  780F00     MOV W0, [W14]
003614  980711     MOV W1, [W14+2]
003616  984742     MOV.B W2, [W14+4]
167:               	while(count--){
003618  37000A     BRA 0x362E
00362E  90424E     MOV.B [W14+4], W4
003630  FB8204     ZE W4, W4
003632  EA0204     NEG W4, W4
003634  DE224F     LSR W4, #15, W4
003636  784204     MOV.B W4, W4
003638  9042CE     MOV.B [W14+4], W5
00363A  E94285     DEC.B W5, W5
00363C  984745     MOV.B W5, [W14+4]
00363E  524FE0     SUB.B W4, #0x0, [W15]
003640  3AFFEC     BRA NZ, 0x361A
168:               		highWrite(reg++,*source++);
00361A  90021E     MOV [W14+2], W4
00361C  784214     MOV.B [W4], W4
00361E  90029E     MOV [W14+2], W5
003620  E80285     INC W5, W5
003622  980715     MOV W5, [W14+2]
003624  78029E     MOV [W14], W5
003626  E80F1E     INC [W14], [W14]
003628  784084     MOV.B W4, W1
00362A  780005     MOV W5, W0
00362C  07FF95     RCALL highWrite
169:               	}	
170:               
171:               	return reg;
003642  78021E     MOV [W14], W4
003644  784204     MOV.B W4, W4
172:               }
003646  784004     MOV.B W4, W0
003648  FA8000     ULNK
00364A  060000     RETURN
173:               
174:               // warm start radio hardware, tunes to Channel.  Takes about 0.37 ms on PIC32 at 20 MHz, 10 MHz SPI hardware clock
175:               // on return, 0=no radio hardare, 1=radio is reset
176:               UINT8 initMRF24J40(void)
177:               {
00364C  FA0002     LNK #0x2
178:               	UINT8 i;
179:               
180:               	MRF24J40Timer=0;
00364E  21FF80     MOV #0x1FF8, W0
003650  B82260     MUL.UU W4, #0, W4
003652  B83360     MUL.UU W6, #0, W6
003654  BE9804     MOV.D W4, [W0++]
003656  BE9006     MOV.D W6, [W0--]
181:               
182:               	RadioStatus.LastTXTriggerTick=0;
003658  21E880     MOV #0x1E88, W0
00365A  B82260     MUL.UU W4, #0, W4
00365C  B83360     MUL.UU W6, #0, W6
00365E  BE9804     MOV.D W4, [W0++]
003660  BE9006     MOV.D W6, [W0--]
183:               	RadioStatus.ResetCount++;
003662  80F424     MOV 0x1E84, W4
003664  80F435     MOV 0x1E86, W5
003666  420261     ADD W4, #0x1, W4
003668  4A82E0     ADDC W5, #0x0, W5
00366A  88F424     MOV W4, 0x1E84
00366C  88F435     MOV W5, 0x1E86
184:               
185:               	RadioStatus.TX_BUSY = 0;		// tx is not busy after reset
00366E  A91E72     BCLR RadioStatus, #0
186:               	RadioStatus.TX_FAIL = 1;		// if we had to reset, consider last packet (if any) as failed
003670  A85E72     BSET RadioStatus, #2
187:               	RadioStatus.TX_PENDING_ACK = 0;		// not pending an ack after reset
003672  A93E72     BCLR RadioStatus, #1
188:               	RadioStatus.SLEEPING = 0;		// radio is not sleeping
003674  A9DE72     BCLR RadioStatus, #6
189:               
190:               	/* do a soft reset */
191:               	lowWrite(WRITE_SOFTRST,0x07);		// reset everything (power, baseband, MAC) (also does wakeup if in sleep)
003676  B3C071     MOV.B #0x7, W1
003678  B3C550     MOV.B #0x55, W0
00367A  07FFB0     RCALL lowWrite
192:               	do {
193:               		i = lowRead(READ_SOFTRST);
00367C  B3C540     MOV.B #0x54, W0
00367E  07FF92     RCALL lowRead
003680  784200     MOV.B W0, W4
003682  784F04     MOV.B W4, [W14]
194:               		if (MRF24J40Timer>200){		// if no reset in a reasonable time (50ms)
003684  21FF84     MOV #0x1FF8, W4
003686  BE0034     MOV.D [W4++], W0
003688  BE0124     MOV.D [W4--], W2
00368A  200C84     MOV #0xC8, W4
00368C  200005     MOV #0x0, W5
00368E  B83360     MUL.UU W6, #0, W6
003690  E10004     CP W0, W4
003692  E18805     CPB W1, W5
003694  E19006     CPB W2, W6
003696  E19807     CPB W3, W7
003698  360002     BRA LEU, 0x369E
195:               			return 0;		// then there is no radio hardware
00369A  EB4200     CLR.B W4
00369C  370053     BRA 0x3744
196:               		}
197:               	}while((i&0x07) != (UINT8)0x00);   	// wait for hardware to clear reset bits
00369E  78429E     MOV.B [W14], W5
0036A0  FB8205     ZE W5, W4
0036A2  620267     AND W4, #0x7, W4
0036A4  520FE0     SUB W4, #0x0, [W15]
0036A6  3AFFEA     BRA NZ, 0x367C
198:               
199:               	lowWrite(WRITE_RXFLUSH,0x01);		// flush the RX fifo, leave WAKE pin disabled
0036A8  B3C011     MOV.B #0x1, W1
0036AA  B3C1B0     MOV.B #0x1B, W0
0036AC  07FF97     RCALL lowWrite
200:               
201:               	RadioSetAddress(RadioStatus.MyShortAddress, RadioStatus.MyLongAddress, RadioStatus.MyPANID);
0036AE  80F411     MOV 0x1E82, W1
0036B0  21E7A4     MOV #0x1E7A, W4
0036B2  BE0354     MOV.D [++W4], W6
0036B4  BE0244     MOV.D [--W4], W4
0036B6  80F3C0     MOV 0x1E78, W0
0036B8  07006E     RCALL RadioSetAddress
202:               
203:               	highWrite(RFCTRL0,0x03);                    // RFOPT=0x03
0036BA  B3C031     MOV.B #0x3, W1
0036BC  202000     MOV #0x200, W0
0036BE  07FF4C     RCALL highWrite
204:               	highWrite(RFCTRL1,0x02);                    // VCOOPT=0x02, per datasheet
0036C0  B3C021     MOV.B #0x2, W1
0036C2  202010     MOV #0x201, W0
0036C4  07FF49     RCALL highWrite
205:               	highWrite(RFCTRL2,0x80);                    // PLL enable
0036C6  B3C801     MOV.B #0x80, W1
0036C8  202020     MOV #0x202, W0
0036CA  07FF46     RCALL highWrite
206:               	highWrite(RFCTRL3, TX_POWER);               // set transmit power
0036CC  EB4080     CLR.B W1
0036CE  202030     MOV #0x203, W0
0036D0  07FF43     RCALL highWrite
207:               	highWrite(RFCTRL6,0x90);                    // TXFILter on, 20MRECVR set to < 3 mS
0036D2  B3C901     MOV.B #0x90, W1
0036D4  202060     MOV #0x206, W0
0036D6  07FF40     RCALL highWrite
208:               	highWrite(RFCTRL7,0x80);                    // sleep clock 100 kHz internal
0036D8  B3C801     MOV.B #0x80, W1
0036DA  202070     MOV #0x207, W0
0036DC  07FF3D     RCALL highWrite
209:               	highWrite(RFCTRL8,0x10);                    // RFVCO to 1
0036DE  B3C101     MOV.B #0x10, W1
0036E0  202080     MOV #0x208, W0
0036E2  07FF3A     RCALL highWrite
210:               
211:               	highWrite(SCLKDIV, 0x21);                   // CLKOUT disabled, sleep clock divisor is 2
0036E4  B3C211     MOV.B #0x21, W1
0036E6  202200     MOV #0x220, W0
0036E8  07FF37     RCALL highWrite
212:               
213:               	lowWrite(WRITE_BBREG2,0x80);                // CCA energy threshold mode
0036EA  B3C801     MOV.B #0x80, W1
0036EC  B3C750     MOV.B #0x75, W0
0036EE  07FF76     RCALL lowWrite
214:               	lowWrite(WRITE_BBREG6,0x40);                // RSSI on every packet
0036F0  B3C401     MOV.B #0x40, W1
0036F2  B3C7D0     MOV.B #0x7D, W0
0036F4  07FF73     RCALL lowWrite
215:               	lowWrite(WRITE_RSSITHCCA,0x60);             // CCA threshold ~ -69 dBm
0036F6  B3C601     MOV.B #0x60, W1
0036F8  B3C7F0     MOV.B #0x7F, W0
0036FA  07FF70     RCALL lowWrite
216:               
217:               	#if defined(ENABLE_PA_LNA)
218:               		highWrite(TESTMODE, 0x0F);          // setup for PA_LNA mode control
219:               	#endif
220:               
221:               	lowWrite(WRITE_FFOEN, 0x98);                // PACON2, per datasheet init
0036FC  B3C981     MOV.B #0x98, W1
0036FE  B3C310     MOV.B #0x31, W0
003700  07FF6D     RCALL lowWrite
222:               	lowWrite(WRITE_TXPEMISP, 0x95);             // TXSTBL; RFSTBL=9, MSIFS-5
003702  B3C951     MOV.B #0x95, W1
003704  B3C5D0     MOV.B #0x5D, W0
003706  07FF6A     RCALL lowWrite
223:               
224:               	while((highRead(RFSTATE)&0xA0) != 0xA0);    // wait till RF state machine in RX mode
003708  000000     NOP
00370A  2020F0     MOV #0x20F, W0
00370C  07FEFE     RCALL highRead
00370E  784200     MOV.B W0, W4
003710  FB8284     ZE W4, W5
003712  200A04     MOV #0xA0, W4
003714  628284     AND W5, W4, W5
003716  200A04     MOV #0xA0, W4
003718  528F84     SUB W5, W4, [W15]
00371A  3AFFF7     BRA NZ, 0x370A
225:               
226:               	lowWrite(WRITE_INTMSK,0b11110110);          // INTCON, enabled=0. RXIE and TXNIE only enabled.
00371C  B3CF61     MOV.B #0xF6, W1
00371E  B3C650     MOV.B #0x65, W0
003720  07FF5D     RCALL lowWrite
227:               
228:               	// Make RF communication stable under extreme temperatures
229:               	highWrite(RFCTRL0, 0x03);                   // this was previously done above
003722  B3C031     MOV.B #0x3, W1
003724  202000     MOV #0x200, W0
003726  07FF18     RCALL highWrite
230:               	highWrite(RFCTRL1, 0x02);                   // VCCOPT - whatever that does...
003728  B3C021     MOV.B #0x2, W1
00372A  202010     MOV #0x201, W0
00372C  07FF15     RCALL highWrite
231:               
232:               	RadioSetChannel(RadioStatus.Channel);       // tune to current radio channel
00372E  21E774     MOV #0x1E77, W4
003730  784214     MOV.B [W4], W4
003732  784004     MOV.B W4, W0
003734  07006C     RCALL RadioSetChannel
233:               
234:               	#ifdef TURBO_MODE		// propriatary TURBO_MODE runs at 625 kbps (vs. 802.15.4 compliant 250 kbps)
235:               		lowWrite(WRITE_BBREG0, 0x01);	// TURBO mode enable
236:               		lowWrite(WRITE_BBREG3, 0x38);	// PREVALIDTH to turbo optimized setting
237:               		lowWrite(WRITE_BBREG4, 0x5C);	// CSTH carrier sense threshold to turbo optimal
238:               	#endif
239:               
240:               	lowWrite(WRITE_RFCTL,0x04);			// reset RF state machine
003736  B3C041     MOV.B #0x4, W1
003738  B3C6D0     MOV.B #0x6D, W0
00373A  07FF50     RCALL lowWrite
241:               	lowWrite(WRITE_RFCTL,0x00);			// back to normal operation
00373C  EB4080     CLR.B W1
00373E  B3C6D0     MOV.B #0x6D, W0
003740  07FF4D     RCALL lowWrite
242:               
243:               	// now delay at least 192 uS per datasheet init
244:               
245:               	return 1;
003742  B3C014     MOV.B #0x1, W4
246:               }
003744  784004     MOV.B W4, W0
003746  FA8000     ULNK
003748  060000     RETURN
247:               
248:               // on return, 1=radio is setup, 0=there is no radio
249:               BOOL RadioInit(void)					// cold start radio init
250:               {
00374A  FA0002     LNK #0x2
251:               	BOOL radio;
252:               
253:               	memset((void*)&RadioStatus, 0, sizeof(RadioStatus));
00374C  200262     MOV #0x26, W2
00374E  EB0080     CLR W1
003750  21E720     MOV #0x1E72, W0
003752  07E756     RCALL _memset
254:               
255:               	RadioStatus.MyPANID 		= MY_PAN_ID;
003754  20F004     MOV #0xF00, W4
003756  88F414     MOV W4, 0x1E82
256:               	RadioStatus.MyShortAddress 	= MY_SHORT_ADDRESS;
003758  20A004     MOV #0xA00, W4
00375A  88F3C4     MOV W4, 0x1E78
257:               	RadioStatus.MyLongAddress  	= MY_LONG_ADDRESS;
00375C  21E7A0     MOV #0x1E7A, W0
00375E  211114     MOV #0x1111, W4
003760  211115     MOV #0x1111, W5
003762  211116     MOV #0x1111, W6
003764  200007     MOV #0x0, W7
003766  BE9804     MOV.D W4, [W0++]
003768  BE9006     MOV.D W6, [W0--]
258:               
259:               	RadioStatus.Channel = 11;			// start at channel 11
00376A  B3C0B4     MOV.B #0xB, W4
00376C  FD0200     EXCH W0, W4
00376E  B7FE77     MOV.B WREG, 0x1E77
003770  FD0200     EXCH W0, W4
260:               
261:               	radio = initMRF24J40();         		// init radio hardware, tune to RadioStatus.Channel
003772  07FF6C     RCALL initMRF24J40
003774  784200     MOV.B W0, W4
003776  FB8204     ZE W4, W4
003778  780F04     MOV W4, [W14]
262:               
263:               
264:               	RADIO_INTPOL=1;					// Interrupt on negative edge.
00377A  A82082     BSET INTCON2, #1
265:               	if (RADIO_INT_PIN==0){
00377C  801655     MOV PORTB, W5
00377E  240004     MOV #0x4000, W4
003780  628204     AND W5, W4, W4
003782  520FE0     SUB W4, #0x0, [W15]
003784  3A0002     BRA NZ, 0x378A
266:               		RADIO_IF=1;
003786  A88086     BSET IFS1, #4
003788  370001     BRA 0x378C
267:               	} else {
268:               		RADIO_IF=0;
00378A  A98086     BCLR IFS1, #4
269:               	}		
270:               	
271:               	RADIO_IE = 1;					// enable radio interrupts
00378C  A88096     BSET IEC1, #4
272:               
273:               	return radio;
00378E  78021E     MOV [W14], W4
274:               }
003790  780004     MOV W4, W0
003792  FA8000     ULNK
003794  060000     RETURN
275:               
276:               // set short address and PANID
277:               void RadioSetAddress(UINT16 shortAddress, UINT64 longAddress, UINT16 panID)
278:               {
003796  FA000E     LNK #0xE
003798  980710     MOV W0, [W14+2]
00379A  980724     MOV W4, [W14+4]
00379C  980735     MOV W5, [W14+6]
00379E  980746     MOV W6, [W14+8]
0037A0  980757     MOV W7, [W14+10]
0037A2  980761     MOV W1, [W14+12]
279:               	UINT8 i;
280:               
281:               	lowWrite(WRITE_SADRL,BYTEPTR(shortAddress)[0]);
0037A4  E8820E     INC2 W14, W4
0037A6  784214     MOV.B [W4], W4
0037A8  784084     MOV.B W4, W1
0037AA  B3C070     MOV.B #0x7, W0
0037AC  07FF17     RCALL lowWrite
282:               	lowWrite(WRITE_SADRH,BYTEPTR(shortAddress)[1]);
0037AE  E8820E     INC2 W14, W4
0037B0  E80204     INC W4, W4
0037B2  784214     MOV.B [W4], W4
0037B4  784084     MOV.B W4, W1
0037B6  B3C090     MOV.B #0x9, W0
0037B8  07FF11     RCALL lowWrite
283:               
284:               	lowWrite(WRITE_PANIDL,BYTEPTR(panID)[0]);
0037BA  47026C     ADD W14, #0xC, W4
0037BC  784214     MOV.B [W4], W4
0037BE  784084     MOV.B W4, W1
0037C0  B3C030     MOV.B #0x3, W0
0037C2  07FF0C     RCALL lowWrite
285:               	lowWrite(WRITE_PANIDH,BYTEPTR(panID)[1]);
0037C4  47026C     ADD W14, #0xC, W4
0037C6  E80204     INC W4, W4
0037C8  784214     MOV.B [W4], W4
0037CA  784084     MOV.B W4, W1
0037CC  B3C050     MOV.B #0x5, W0
0037CE  07FF06     RCALL lowWrite
286:               
287:               	for(i=0;i<sizeof(longAddress);i++){	// program long MAC address
0037D0  EB4200     CLR.B W4
0037D2  784F04     MOV.B W4, [W14]
0037D4  37000C     BRA 0x37EE
0037EC  E84F1E     INC.B [W14], [W14]
0037EE  78421E     MOV.B [W14], W4
0037F0  524FE7     SUB.B W4, #0x7, [W15]
0037F2  36FFF1     BRA LEU, 0x37D6
288:               		lowWrite(WRITE_EADR0+i*2,BYTEPTR(longAddress)[i]);
0037D6  4702E4     ADD W14, #0x4, W5
0037D8  78431E     MOV.B [W14], W6
0037DA  FB8206     ZE W6, W4
0037DC  428204     ADD W5, W4, W4
0037DE  784294     MOV.B [W4], W5
0037E0  78421E     MOV.B [W14], W4
0037E2  424204     ADD.B W4, W4, W4
0037E4  42426B     ADD.B W4, #0xB, W4
0037E6  784085     MOV.B W5, W1
0037E8  784004     MOV.B W4, W0
0037EA  07FEF8     RCALL lowWrite
289:               	}	
290:               
291:               	RadioStatus.MyPANID 		= panID;
0037F4  90026E     MOV [W14+12], W4
0037F6  88F414     MOV W4, 0x1E82
292:               	RadioStatus.MyShortAddress 	= shortAddress;
0037F8  90021E     MOV [W14+2], W4
0037FA  88F3C4     MOV W4, 0x1E78
293:               	RadioStatus.MyLongAddress  	= longAddress;
0037FC  90022E     MOV [W14+4], W4
0037FE  9002BE     MOV [W14+6], W5
003800  90034E     MOV [W14+8], W6
003802  9003DE     MOV [W14+10], W7
003804  21E7A0     MOV #0x1E7A, W0
003806  BE9804     MOV.D W4, [W0++]
003808  BE9006     MOV.D W6, [W0--]
294:               }
00380A  FA8000     ULNK
00380C  060000     RETURN
295:               
296:               // Set radio channel.  Returns with success/fail flag.
297:               BOOL RadioSetChannel(UINT8 channel)
298:               {
00380E  FA0002     LNK #0x2
003810  784F00     MOV.B W0, [W14]
299:               	if( channel < 11 || channel > 26){
003812  78421E     MOV.B [W14], W4
003814  524FEA     SUB.B W4, #0xA, [W15]
003816  360003     BRA LEU, 0x381E
003818  78421E     MOV.B [W14], W4
00381A  524FFA     SUB.B W4, #0x1A, [W15]
00381C  360002     BRA LEU, 0x3822
300:               		return FALSE;
00381E  EB0200     CLR W4
003820  370012     BRA 0x3846
301:               	}
302:               
303:               	#if defined(ENABLE_PA_LNA)	// Permitted band is 2400 to 2483.5 MHz.
304:               		if( channel == 26 ){	// Center Freq. is 2405+5(k-11) MHz, for k=channel 11 to 26
305:               			return FALSE;		// max output is 100mW (USA)
306:               		}	
307:               	#endif						// rolloff is not steep enough to avoid 2483.5 from channel 26 center of 2480 MHz at full MB power
308:               
309:               	RadioStatus.Channel = channel;
003822  78401E     MOV.B [W14], W0
003824  B7FE77     MOV.B WREG, 0x1E77
310:               	highWrite(RFCTRL0,((channel-11)<<4)|0x03);
003826  78429E     MOV.B [W14], W5
003828  FB8205     ZE W5, W4
00382A  52026B     SUB W4, #0xB, W4
00382C  DD2244     SL W4, #4, W4
00382E  784204     MOV.B W4, W4
003830  B34034     IOR.B #0x3, W4
003832  784084     MOV.B W4, W1
003834  202000     MOV #0x200, W0
003836  07FE90     RCALL highWrite
311:               	lowWrite(WRITE_RFCTL,0x04);	// reset RF state machine
003838  B3C041     MOV.B #0x4, W1
00383A  B3C6D0     MOV.B #0x6D, W0
00383C  07FECF     RCALL lowWrite
312:               	lowWrite(WRITE_RFCTL,0x00);	// back to normal
00383E  EB4080     CLR.B W1
003840  B3C6D0     MOV.B #0x6D, W0
003842  07FECC     RCALL lowWrite
313:               
314:               	return TRUE;
003844  200014     MOV #0x1, W4
315:               }
003846  780004     MOV W4, W0
003848  FA8000     ULNK
00384A  060000     RETURN
316:               
317:               // Put the RF transceiver into sleep or wake it up
318:               // Radio power, MRF24J40MB - ENABLE_PA_LNA on:
319:               //	RX:  	28.4 mA
320:               //	TX: 	65.8 mA (as fast as I can xmit; nominal peak 130 mA)
321:               //	Sleep:	0.245 mA (spec is 5 uA with 'sleep clock disabled'; setting register 0x211 to 0x01 doesn't seem to help)
322:               // Note that you can in practice turn the radio power off completely for short periods (with a MOSFET) and then do a warm start.
323:               void RadioSetSleep(UINT8 powerState)
324:               {
00384C  FA0002     LNK #0x2
00384E  784F00     MOV.B W0, [W14]
325:               	if (powerState){
003850  78421E     MOV.B [W14], W4
003852  524FE0     SUB.B W4, #0x0, [W15]
003854  32000B     BRA Z, 0x386C
326:               		#if defined(ENABLE_PA_LNA)
327:               			highWrite(TESTMODE, 0x08);      // Disable automatic switch on PA/LNA
328:               			lowWrite(WRITE_GPIODIR, 0x0F);	// Set GPIO direction to OUTPUT (control PA/LNA)
329:               			lowWrite(WRITE_GPIO, 0x00);     // Disable PA and LNA
330:               		#endif
331:               
332:               		lowWrite(WRITE_SOFTRST, 0x04);		// power management reset to ensure device goes to sleep
003856  B3C041     MOV.B #0x4, W1
003858  B3C550     MOV.B #0x55, W0
00385A  07FEC0     RCALL lowWrite
333:               		lowWrite(WRITE_WAKECON,0x80);		// WAKECON; enable immediate wakeup
00385C  B3C801     MOV.B #0x80, W1
00385E  B3C450     MOV.B #0x45, W0
003860  07FEBD     RCALL lowWrite
334:               		lowWrite(WRITE_SLPACK,0x80);		// SLPACK; force radio to sleep now
003862  B3C801     MOV.B #0x80, W1
003864  B3C6B0     MOV.B #0x6B, W0
003866  07FEBA     RCALL lowWrite
335:               
336:               		RadioStatus.SLEEPING = 1;			// radio is sleeping
003868  A8DE72     BSET RadioStatus, #6
00386A  370001     BRA 0x386E
337:               	} else {
338:               		initMRF24J40();		// could wakeup with WAKE pin or by toggling REGWAKE (1 then 0), but this is simpler
00386C  07FEEF     RCALL initMRF24J40
339:               	}	
340:               }
00386E  FA8000     ULNK
003870  060000     RETURN
341:               
342:               // Do a single (128 us) energy scan on current channel.  Return RSSI.
343:               UINT8 RadioEnergyDetect(void)
344:               {
003872  FA0002     LNK #0x2
345:               	UINT8 RSSIcheck;
346:               
347:               	#if defined(ENABLE_PA_LNA)
348:               		highWrite(TESTMODE, 0x08);          // Disable automatic switch on PA/LNA
349:               		lowWrite(WRITE_GPIODIR, 0x0F);      // Set GPIO direction to OUTPUT (control PA/LNA)
350:               		lowWrite(WRITE_GPIO, 0x0C);         // Enable LNA, disable PA
351:               	#endif
352:               
353:               	lowWrite(WRITE_BBREG6, 0x80);			// set RSSIMODE1 to initiate RSSI measurement
003874  B3C801     MOV.B #0x80, W1
003876  B3C7D0     MOV.B #0x7D, W0
003878  07FEB1     RCALL lowWrite
354:               
355:               	RSSIcheck = lowRead (READ_BBREG6);		// Read RSSIRDY
00387A  B3C7C0     MOV.B #0x7C, W0
00387C  07FE93     RCALL lowRead
00387E  784200     MOV.B W0, W4
003880  784F04     MOV.B W4, [W14]
356:               	while ((RSSIcheck & 0x01) != 0x01){		// Wait until RSSIRDY goes to 1; this indicates result is ready
003882  370004     BRA 0x388C
00388C  78429E     MOV.B [W14], W5
00388E  FB8205     ZE W5, W4
003890  620261     AND W4, #0x1, W4
003892  520FE0     SUB W4, #0x0, [W15]
003894  32FFF7     BRA Z, 0x3884
357:               		RSSIcheck = lowRead (READ_BBREG6);	// this takes max 8 symbol periods (16 uS each = 128 uS)
003884  B3C7C0     MOV.B #0x7C, W0
003886  07FE8E     RCALL lowRead
003888  784200     MOV.B W0, W4
00388A  784F04     MOV.B W4, [W14]
358:               	}	
359:               
360:               	RSSIcheck = highRead(0x210);			// read the RSSI
003896  202100     MOV #0x210, W0
003898  07FE38     RCALL highRead
00389A  784200     MOV.B W0, W4
00389C  784F04     MOV.B W4, [W14]
361:               
362:               	lowWrite(WRITE_BBREG6, 0x40);			// enable RSSI on received packets again after energy scan is finished
00389E  B3C401     MOV.B #0x40, W1
0038A0  B3C7D0     MOV.B #0x7D, W0
0038A2  07FE9C     RCALL lowWrite
363:               
364:               	#if defined(ENABLE_PA_LNA)
365:               		lowWrite(WRITE_GPIO, 0);
366:               		lowWrite(WRITE_GPIODIR, 0x00);		// Set GPIO direction to INPUT
367:               		highWrite(TESTMODE, 0x0F);			// setup for automatic PA/LNA control
368:               	#endif
369:               
370:               	return RSSIcheck;
0038A4  78421E     MOV.B [W14], W4
371:               }
0038A6  784004     MOV.B W4, W0
0038A8  FA8000     ULNK
0038AA  060000     RETURN
372:               
373:               // TX side - what goes in the TX FIFO (MRF24J40 datahseet figure 3-11):
374:               //
375:               // Size Offset	Descr
376:               // 1		0		Header length (m)
377:               // 1		1		Frame length (m+n)
378:               // 1		2		LSB of Frame Control (bits/i)
379:               // 1		3		MSB of Frame Control (type)
380:               // 1		4		Sequence number
381:               // 20		24		Addressing fields, worst case (PANIDx2 = 4, LONGx2=16 total =20)
382:               // 103		127		Payload (from TxBuffer)
383:               
384:               // sends raw packet per already setup Tx structure.  No error checking here.
385:               void RadioTXRaw(void)
386:               {
0038AC  FA0002     LNK #0x2
387:               	UINT8 wReg;								// radio write register (into TX FIFO starting at long addr 0)
388:               
389:               //	wReg = toTXfifo(2,BYTEPTR(Tx)+1,2+1);					// frame control (2) + sequence number (1) 
390:               	wReg = toTXfifo(2,BYTEPTR(Tx.frameControl),2);
0038AE  21FBA4     MOV #0x1FBA, W4
0038B0  B3C022     MOV.B #0x2, W2
0038B2  780084     MOV W4, W1
0038B4  200020     MOV #0x2, W0
0038B6  07FEAC     RCALL toTXfifo
0038B8  784200     MOV.B W0, W4
0038BA  784F04     MOV.B W4, [W14]
391:               	wReg = toTXfifo(wReg,BYTEPTR(Tx.frameNumber),1);
0038BC  78429E     MOV.B [W14], W5
0038BE  FB8205     ZE W5, W4
0038C0  B3C012     MOV.B #0x1, W2
0038C2  21FBC1     MOV #0x1FBC, W1
0038C4  780004     MOV W4, W0
0038C6  07FEA4     RCALL toTXfifo
0038C8  784200     MOV.B W0, W4
0038CA  784F04     MOV.B W4, [W14]
392:               
393:               	if (Tx.frameControl.dstAddrMode == SHORT_ADDR_FIELD){			// if a short dest addr is present
0038CC  80FDD5     MOV 0x1FBA, W5
0038CE  20C004     MOV #0xC00, W4
0038D0  628284     AND W5, W4, W5
0038D2  208004     MOV #0x800, W4
0038D4  528F84     SUB W5, W4, [W15]
0038D6  3A0013     BRA NZ, 0x38FE
394:               		wReg = toTXfifo(wReg,BYTEPTR(Tx.dstPANID), 2);			// write dstPANID
0038D8  21FBE5     MOV #0x1FBE, W5
0038DA  78431E     MOV.B [W14], W6
0038DC  FB8206     ZE W6, W4
0038DE  B3C022     MOV.B #0x2, W2
0038E0  780085     MOV W5, W1
0038E2  780004     MOV W4, W0
0038E4  07FE95     RCALL toTXfifo
0038E6  784200     MOV.B W0, W4
0038E8  784F04     MOV.B W4, [W14]
395:               		wReg = toTXfifo(wReg,BYTEPTR(Tx.dstAddr), 2);			// write short address
0038EA  21FC05     MOV #0x1FC0, W5
0038EC  78439E     MOV.B [W14], W7
0038EE  FB8207     ZE W7, W4
0038F0  B3C022     MOV.B #0x2, W2
0038F2  780085     MOV W5, W1
0038F4  780004     MOV W4, W0
0038F6  07FE8C     RCALL toTXfifo
0038F8  784200     MOV.B W0, W4
0038FA  784F04     MOV.B W4, [W14]
0038FC  370018     BRA 0x392E
396:               	} else if (Tx.frameControl.dstAddrMode == LONG_ADDR_FIELD){		// if a long dest addr is present
0038FE  80FDD5     MOV 0x1FBA, W5
003900  20C004     MOV #0xC00, W4
003902  628284     AND W5, W4, W5
003904  20C004     MOV #0xC00, W4
003906  528F84     SUB W5, W4, [W15]
003908  3A0012     BRA NZ, 0x392E
397:               		wReg = toTXfifo(wReg,BYTEPTR(Tx.dstPANID), 2);			// write dstPANID
00390A  21FBE5     MOV #0x1FBE, W5
00390C  78431E     MOV.B [W14], W6
00390E  FB8206     ZE W6, W4
003910  B3C022     MOV.B #0x2, W2
003912  780085     MOV W5, W1
003914  780004     MOV W4, W0
003916  07FE7C     RCALL toTXfifo
003918  784200     MOV.B W0, W4
00391A  784F04     MOV.B W4, [W14]
398:               		wReg = toTXfifo(wReg,BYTEPTR(Tx.dstAddr), 8);			// long addr
00391C  21FC05     MOV #0x1FC0, W5
00391E  78439E     MOV.B [W14], W7
003920  FB8207     ZE W7, W4
003922  B3C082     MOV.B #0x8, W2
003924  780085     MOV W5, W1
003926  780004     MOV W4, W0
003928  07FE73     RCALL toTXfifo
00392A  784200     MOV.B W0, W4
00392C  784F04     MOV.B W4, [W14]
399:               	}
400:               
401:               	// now wReg is at start of source PANID (if present)
402:               
403:               	if ( Tx.frameControl.srcAddrMode != NO_ADDR_FIELD && 			// if source present
00392E  80FDD5     MOV 0x1FBA, W5
003930  2C0004     MOV #0xC000, W4
003932  628204     AND W5, W4, W4
003934  520FE0     SUB W4, #0x0, [W15]
003936  320013     BRA Z, 0x395E
00393E  520FE0     SUB W4, #0x0, [W15]
003940  32000E     BRA Z, 0x395E
404:               		 Tx.frameControl.dstAddrMode != NO_ADDR_FIELD && 		// and dest present
003938  80FDD5     MOV 0x1FBA, W5
00393A  20C004     MOV #0xC00, W4
00393C  628204     AND W5, W4, W4
003948  520FE0     SUB W4, #0x0, [W15]
00394A  3A0009     BRA NZ, 0x395E
405:               		 !Tx.frameControl.panIDcomp ){					// and no PANID compression
003942  80FDD5     MOV 0x1FBA, W5
003944  200404     MOV #0x40, W4
003946  628204     AND W5, W4, W4
406:               		wReg = toTXfifo(wReg,BYTEPTR(Tx.srcPANID), 2);			// then write src PANID
00394C  21FC85     MOV #0x1FC8, W5
00394E  78431E     MOV.B [W14], W6
003950  FB8206     ZE W6, W4
003952  B3C022     MOV.B #0x2, W2
003954  780085     MOV W5, W1
003956  780004     MOV W4, W0
003958  07FE5B     RCALL toTXfifo
00395A  784200     MOV.B W0, W4
00395C  784F04     MOV.B W4, [W14]
407:               	}
408:               		
409:               	if (Tx.frameControl.srcAddrMode == SHORT_ADDR_FIELD){			// if a short src addr is present
00395E  80FDD5     MOV 0x1FBA, W5
003960  2C0004     MOV #0xC000, W4
003962  628284     AND W5, W4, W5
003964  280004     MOV #0x8000, W4
003966  528F84     SUB W5, W4, [W15]
003968  3A000A     BRA NZ, 0x397E
410:               		wReg = toTXfifo(wReg,BYTEPTR(Tx.srcAddr), 2);
00396A  21FCA5     MOV #0x1FCA, W5
00396C  78439E     MOV.B [W14], W7
00396E  FB8207     ZE W7, W4
003970  B3C022     MOV.B #0x2, W2
003972  780085     MOV W5, W1
003974  780004     MOV W4, W0
003976  07FE4C     RCALL toTXfifo
003978  784200     MOV.B W0, W4
00397A  784F04     MOV.B W4, [W14]
00397C  37000F     BRA 0x399C
411:               	} else if (Tx.frameControl.srcAddrMode == LONG_ADDR_FIELD){		// if a long src addr is present
00397E  80FDD5     MOV 0x1FBA, W5
003980  2C0004     MOV #0xC000, W4
003982  628284     AND W5, W4, W5
003984  2C0004     MOV #0xC000, W4
003986  528F84     SUB W5, W4, [W15]
003988  3A0009     BRA NZ, 0x399C
412:               		wReg = toTXfifo(wReg,BYTEPTR(Tx.srcAddr), 8);
00398A  21FCA5     MOV #0x1FCA, W5
00398C  78431E     MOV.B [W14], W6
00398E  FB8206     ZE W6, W4
003990  B3C082     MOV.B #0x8, W2
003992  780085     MOV W5, W1
003994  780004     MOV W4, W0
003996  07FE3C     RCALL toTXfifo
003998  784200     MOV.B W0, W4
00399A  784F04     MOV.B W4, [W14]
413:               	}	
414:               	
415:               	// now wReg is pointing to first wReg after header (m)
416:               	
417:               	highWrite(0, wReg-2);							// header length, m (-2 for header & frame lengths)
00399C  E9C21E     DEC2.B [W14], W4
00399E  784084     MOV.B W4, W1
0039A0  EB0000     CLR W0
0039A2  07FDDA     RCALL highWrite
418:               
419:               	wReg = toTXfifo(wReg,Tx.payload,Tx.payloadLength);
0039A4  21FD24     MOV #0x1FD2, W4
0039A6  784214     MOV.B [W4], W4
0039A8  80FEA6     MOV 0x1FD4, W6
0039AA  78439E     MOV.B [W14], W7
0039AC  FB8287     ZE W7, W5
0039AE  784104     MOV.B W4, W2
0039B0  780086     MOV W6, W1
0039B2  780005     MOV W5, W0
0039B4  07FE2D     RCALL toTXfifo
0039B6  784200     MOV.B W0, W4
0039B8  784F04     MOV.B W4, [W14]
420:               
421:               	highWrite(1, wReg-2);							// frame length (m+n)
0039BA  E9C21E     DEC2.B [W14], W4
0039BC  784084     MOV.B W4, W1
0039BE  200010     MOV #0x1, W0
0039C0  07FDCB     RCALL highWrite
422:               
423:               	RadioStatus.TX_BUSY = 1;						// mark TX as busy TXing
0039C2  A81E72     BSET RadioStatus, #0
424:               	RadioStatus.TX_PENDING_ACK = Tx.frameControl.ackRequest;
0039C4  80FDD4     MOV 0x1FBA, W4
0039C6  DE2245     LSR W4, #5, W4
0039C8  624261     AND.B W4, #0x1, W4
0039CA  FB8204     ZE W4, W4
0039CC  620261     AND W4, #0x1, W4
0039CE  420204     ADD W4, W4, W4
0039D0  80F396     MOV RadioStatus, W6
0039D2  2FFFD5     MOV #0xFFFD, W5
0039D4  630285     AND W6, W5, W5
0039D6  720205     IOR W4, W5, W4
0039D8  88F394     MOV W4, RadioStatus
425:               
426:               	lowWrite(WRITE_TXNMTRIG, Tx.frameControl.ackRequest << 2 | 1);		// kick off transmit with above parameters
0039DA  80FDD4     MOV 0x1FBA, W4
0039DC  DE2245     LSR W4, #5, W4
0039DE  624261     AND.B W4, #0x1, W4
0039E0  FB8204     ZE W4, W4
0039E2  DD2242     SL W4, #2, W4
0039E4  784204     MOV.B W4, W4
0039E6  A00404     BSET.B W4, #0
0039E8  784084     MOV.B W4, W1
0039EA  B3C370     MOV.B #0x37, W0
0039EC  07FDF7     RCALL lowWrite
427:               	RadioStatus.LastTXTriggerTick = MRF24J40Timer;				// record time (used to check for locked-up radio or PLL loss)
0039EE  21FF84     MOV #0x1FF8, W4
0039F0  BE0354     MOV.D [++W4], W6
0039F2  BE0244     MOV.D [--W4], W4
0039F4  21E880     MOV #0x1E88, W0
0039F6  BE9804     MOV.D W4, [W0++]
0039F8  BE9006     MOV.D W6, [W0--]
428:               }
0039FA  FA8000     ULNK
0039FC  060000     RETURN
429:               
430:               // Sends next packet from Tx.  Blocks for up to MRF24J40_TIMEOUT_TICKS if transmitter is
431:               // not ready (RadioStatus.TX_BUSY).  If you don't want to be blocked, don't call
432:               // ths until RadioStatus.TX_BUSY == 0.  
433:               //
434:               // This automatically sets frame number and source address for you
435:               void RadioTXPacket(void)
436:               {
0039FE  FA0000     LNK #0x0
437:               	if (Tx.frameControl.srcAddrMode == SHORT_ADDR_FIELD){
003A00  80FDD5     MOV 0x1FBA, W5
003A02  2C0004     MOV #0xC000, W4
003A04  628284     AND W5, W4, W5
003A06  280004     MOV #0x8000, W4
003A08  528F84     SUB W5, W4, [W15]
003A0A  3A0008     BRA NZ, 0x3A1C
438:               		Tx.srcAddr = RadioStatus.MyShortAddress;
003A0C  80F3C4     MOV 0x1E78, W4
003A0E  200005     MOV #0x0, W5
003A10  200006     MOV #0x0, W6
003A12  200007     MOV #0x0, W7
003A14  21FCA0     MOV #0x1FCA, W0
003A16  BE9804     MOV.D W4, [W0++]
003A18  BE9006     MOV.D W6, [W0--]
003A1A  37000C     BRA 0x3A34
439:               	} else if (Tx.frameControl.srcAddrMode == LONG_ADDR_FIELD){
003A1C  80FDD5     MOV 0x1FBA, W5
003A1E  2C0004     MOV #0xC000, W4
003A20  628284     AND W5, W4, W5
003A22  2C0004     MOV #0xC000, W4
003A24  528F84     SUB W5, W4, [W15]
003A26  3A0006     BRA NZ, 0x3A34
440:               		Tx.srcAddr = RadioStatus.MyLongAddress;
003A28  21E7A4     MOV #0x1E7A, W4
003A2A  BE0354     MOV.D [++W4], W6
003A2C  BE0244     MOV.D [--W4], W4
003A2E  21FCA0     MOV #0x1FCA, W0
003A30  BE9804     MOV.D W4, [W0++]
003A32  BE9006     MOV.D W6, [W0--]
441:               	}	
442:               
443:               	Tx.frameNumber = RadioStatus.IEEESeqNum++;
003A34  21E764     MOV #0x1E76, W4
003A36  784214     MOV.B [W4], W4
003A38  FD0200     EXCH W0, W4
003A3A  B7FFBC     MOV.B WREG, 0x1FBC
003A3C  FD0200     EXCH W0, W4
003A3E  E84204     INC.B W4, W4
003A40  FD0200     EXCH W0, W4
003A42  B7FE76     MOV.B WREG, 0x1E76
003A44  FD0200     EXCH W0, W4
444:               
445:               	while(RadioStatus.TX_BUSY){						// If TX is busy, wait for it to clear (for a resaonable time)
003A46  37000F     BRA 0x3A66
003A66  80F394     MOV RadioStatus, W4
003A68  620261     AND W4, #0x1, W4
003A6A  520FE0     SUB W4, #0x0, [W15]
003A6C  3AFFED     BRA NZ, 0x3A48
446:               		if (timerTicksSince(RadioStatus.LastTXTriggerTick) > MRF24J40_TIMEOUT_TICKS ){
003A48  21E884     MOV #0x1E88, W4
003A4A  BE0354     MOV.D [++W4], W6
003A4C  BE0244     MOV.D [--W4], W4
003A4E  BE0004     MOV.D W4, W0
003A50  BE0106     MOV.D W6, W2
003A52  07FCF7     RCALL timerTicksSince
003A54  2004E4     MOV #0x4E, W4
003A56  200005     MOV #0x0, W5
003A58  B83360     MUL.UU W6, #0, W6
003A5A  E10004     CP W0, W4
003A5C  E18805     CPB W1, W5
003A5E  E19006     CPB W2, W6
003A60  E19807     CPB W3, W7
003A62  360001     BRA LEU, 0x3A66
447:               										// if not ready in a resonable time
448:               			initMRF24J40();						// reset radio hardware (stay on same channel)
003A64  07FDF3     RCALL initMRF24J40
449:               		}
450:               	}		
451:               
452:               	RadioTXRaw();
003A6E  07FF1E     RCALL RadioTXRaw
453:               }
003A70  FA8000     ULNK
003A72  060000     RETURN
454:               
455:               
456:               // returns status of last transmitted packet: TX_SUCCESS (1), TX_FAILED (2), or 0 = no result yet because TX busy
457:               UINT8 RadioTXResult(void)
458:               {
003A74  FA0000     LNK #0x0
459:               	if (RadioStatus.TX_BUSY){						// if TX not done yet
003A76  80F394     MOV RadioStatus, W4
003A78  620261     AND W4, #0x1, W4
003A7A  520FE0     SUB W4, #0x0, [W15]
003A7C  320002     BRA Z, 0x3A82
460:               		return TX_RESULT_BUSY;
003A7E  EB4200     CLR.B W4
003A80  370004     BRA 0x3A8A
461:               	}	
462:               				
463:               	return TX_RESULT_SUCCESS + RadioStatus.TX_FAIL;				// 1=success, 2=fail
003A82  80F394     MOV RadioStatus, W4
003A84  DE2242     LSR W4, #2, W4
003A86  624261     AND.B W4, #0x1, W4
003A88  E84204     INC.B W4, W4
464:               }
003A8A  784004     MOV.B W4, W0
003A8C  FA8000     ULNK
003A8E  060000     RETURN
465:               
466:               // returns TX_RESULT_SUCCESS or TX_RESULT_FAILED.  Waits up to MRF24J40_TIMEOUT_TICKS.
467:               UINT8 RadioWaitTXResult(void)
468:               {
003A90  FA0000     LNK #0x0
469:               	while(RadioStatus.TX_BUSY){						// If TX is busy, wait for it to clear (for a resaonable time)
003A92  37000F     BRA 0x3AB2
003AB2  80F394     MOV RadioStatus, W4
003AB4  620261     AND W4, #0x1, W4
003AB6  520FE0     SUB W4, #0x0, [W15]
003AB8  3AFFED     BRA NZ, 0x3A94
470:               		if ( timerTicksSince(RadioStatus.LastTXTriggerTick) > MRF24J40_TIMEOUT_TICKS ){		// if not ready in a resonable time
003A94  21E884     MOV #0x1E88, W4
003A96  BE0354     MOV.D [++W4], W6
003A98  BE0244     MOV.D [--W4], W4
003A9A  BE0004     MOV.D W4, W0
003A9C  BE0106     MOV.D W6, W2
003A9E  07FCD1     RCALL timerTicksSince
003AA0  2004E4     MOV #0x4E, W4
003AA2  200005     MOV #0x0, W5
003AA4  B83360     MUL.UU W6, #0, W6
003AA6  E10004     CP W0, W4
003AA8  E18805     CPB W1, W5
003AAA  E19006     CPB W2, W6
003AAC  E19807     CPB W3, W7
003AAE  360001     BRA LEU, 0x3AB2
471:               			initMRF24J40();									// reset radio hardware (stay on same channel)
003AB0  07FDCD     RCALL initMRF24J40
472:               		}
473:               	}
474:               
475:               	return TX_RESULT_SUCCESS + RadioStatus.TX_FAIL;				// 1=success, 2=fail
003ABA  80F394     MOV RadioStatus, W4
003ABC  DE2242     LSR W4, #2, W4
003ABE  624261     AND.B W4, #0x1, W4
003AC0  E84204     INC.B W4, W4
476:               }
003AC2  784004     MOV.B W4, W0
003AC4  FA8000     ULNK
003AC6  060000     RETURN
477:               
478:               
479:               //	RX side - what goes in RXBuffer (from MRF24J40 datasheet figure 3-9)
480:               //
481:               //	Size	Offset
482:               //	1		0		Frame length (m+n+2 = header + 102 + FCS)
483:               //	1		1		LSB of Frame Control (bits)
484:               //	1		2		MSB of Frame Control (type)
485:               //	1		3		Sequence number
486:               //	20		23		Addressing fields, worst case (PANIDx2 = 4, MACx2=16 total =20)
487:               //	103		126		Payload
488:               //	2		128		FCS
489:               //	1		129		LQI
490:               //	1		130		RSSI
491:               
492:               // Returns count of received packets waiting to be processed & discarded.  Next packet to process is in "Rx".
493:               // Note this gives you ALL received packets (not just ones addressed to you).   Check the addressing yourself if you care.
494:               // Also be aware that sucessive identical packets (same frame number) will be received if the far-end misses your ACK (it
495:               // will re-transmit).  Check for that if you care.
496:               UINT8 RadioRXPacket(void)
497:               {
003AC8  FA0002     LNK #0x2
498:               	if (!RadioStatus.RXPacketCount){
003ACA  21E754     MOV #0x1E75, W4
003ACC  784214     MOV.B [W4], W4
003ACE  524FE0     SUB.B W4, #0x0, [W15]
003AD0  3A0002     BRA NZ, 0x3AD6
499:               		return 0;							// no packets to process
003AD2  EB4200     CLR.B W4
003AD4  3700DD     BRA 0x3C90
500:               	}
501:               
502:               	UINT8* readPoint = (UINT8*)RXBuffer[RadioStatus.RXReadBuffer];		// recieved packet read point
003AD6  21E986     MOV #0x1E98, W6
003AD8  21E744     MOV #0x1E74, W4
003ADA  784214     MOV.B [W4], W4
003ADC  FB8284     ZE W4, W5
003ADE  200904     MOV #0x90, W4
003AE0  B9AA04     MUL.SS W5, W4, W4
003AE2  780204     MOV W4, W4
003AE4  430F04     ADD W6, W4, [W14]
503:               
504:               	if(RadioStatus.TX_BUSY){						// time out and reset radio if we missed interrupts for a long time
003AE6  80F394     MOV RadioStatus, W4
003AE8  620261     AND W4, #0x1, W4
003AEA  520FE0     SUB W4, #0x0, [W15]
003AEC  32000F     BRA Z, 0x3B0C
505:               		if ( timerTicksSince(RadioStatus.LastTXTriggerTick) > MRF24J40_TIMEOUT_TICKS ){
003AEE  21E884     MOV #0x1E88, W4
003AF0  BE0354     MOV.D [++W4], W6
003AF2  BE0244     MOV.D [--W4], W4
003AF4  BE0004     MOV.D W4, W0
003AF6  BE0106     MOV.D W6, W2
003AF8  07FCA4     RCALL timerTicksSince
003AFA  2004E4     MOV #0x4E, W4
003AFC  200005     MOV #0x0, W5
003AFE  B83360     MUL.UU W6, #0, W6
003B00  E10004     CP W0, W4
003B02  E18805     CPB W1, W5
003B04  E19006     CPB W2, W6
003B06  E19807     CPB W3, W7
003B08  360001     BRA LEU, 0x3B0C
506:               			initMRF24J40();						// reset radio hardware (stay on same channel)
003B0A  07FDA0     RCALL initMRF24J40
507:               		}
508:               	}		
509:               
510:               	readPoint = readBytes(BYTEPTR(Rx.frameLength), readPoint, 1);		// copy frame length (1), frame control (2), frame number (1), PANID (2)
003B0C  200012     MOV #0x1, W2
003B0E  78009E     MOV [W14], W1
003B10  21FD80     MOV #0x1FD8, W0
003B12  07FCA7     RCALL readBytes
003B14  780200     MOV W0, W4
003B16  780F04     MOV W4, [W14]
511:               	readPoint = readBytes(BYTEPTR(Rx.frameControl.w),readPoint,2);
003B18  21FDA4     MOV #0x1FDA, W4
003B1A  200022     MOV #0x2, W2
003B1C  78009E     MOV [W14], W1
003B1E  780004     MOV W4, W0
003B20  07FCA0     RCALL readBytes
003B22  780200     MOV W0, W4
003B24  780F04     MOV W4, [W14]
512:               	readPoint = readBytes(BYTEPTR(Rx.frameNumber),readPoint,1);
003B26  200012     MOV #0x1, W2
003B28  78009E     MOV [W14], W1
003B2A  21FDC0     MOV #0x1FDC, W0
003B2C  07FC9A     RCALL readBytes
003B2E  780200     MOV W0, W4
003B30  780F04     MOV W4, [W14]
513:               	readPoint = readBytes(BYTEPTR(Rx.dstPANID),readPoint,2);
003B32  21FDE4     MOV #0x1FDE, W4
003B34  200022     MOV #0x2, W2
003B36  78009E     MOV [W14], W1
003B38  780004     MOV W4, W0
003B3A  07FC93     RCALL readBytes
003B3C  780200     MOV W0, W4
003B3E  780F04     MOV W4, [W14]
514:               	
515:               	if( Rx.frameControl.securityEnabled )					// if security enabled, toss it (not supported)
003B40  80FED4     MOV 0x1FDA, W4
003B42  620268     AND W4, #0x8, W4
003B44  520FE0     SUB W4, #0x0, [W15]
003B46  320007     BRA Z, 0x3B56
516:               	{
517:               		RadioStatus.RXSecurityEnabled++;				// log error
003B48  80F484     MOV 0x1E90, W4
003B4A  E80204     INC W4, W4
003B4C  88F484     MOV W4, 0x1E90
518:               		RadioDiscardPacket();
003B4E  0700A3     RCALL RadioDiscardPacket
519:               		return RadioRXPacket();						// yes I know it's a little recursive, but the RXBuffer is
003B50  07FFBB     RCALL RadioRXPacket
003B52  784200     MOV.B W0, W4
003B54  37009D     BRA 0x3C90
520:                                                                                               // small enough that the stack is unlikely to overflow
521:                       }
522:               
523:               	if (Rx.frameControl.frameType == PACKET_TYPE_ACK){			// no PANID present on ACK frames [802.15.4 weakness: No way to know if this ACK is really for you]
003B56  80FED4     MOV 0x1FDA, W4
003B58  620267     AND W4, #0x7, W4
003B5A  520FE2     SUB W4, #0x2, [W15]
003B5C  3A0001     BRA NZ, 0x3B60
524:               		readPoint -= 2;
003B5E  E98F1E     DEC2 [W14], [W14]
525:               	}	
526:               
527:               	// readPoint now just after first PANID field
528:               
529:               	if (Rx.frameControl.dstAddrMode == SHORT_ADDR_FIELD)			// if a short dest addr is present
003B60  80FED5     MOV 0x1FDA, W5
003B62  20C004     MOV #0xC00, W4
003B64  628284     AND W5, W4, W5
003B66  208004     MOV #0x800, W4
003B68  528F84     SUB W5, W4, [W15]
003B6A  3A0008     BRA NZ, 0x3B7C
530:               		readPoint = readBytes(BYTEPTR(Rx.dstAddr), readPoint, 2);
003B6C  21FE04     MOV #0x1FE0, W4
003B6E  200022     MOV #0x2, W2
003B70  78009E     MOV [W14], W1
003B72  780004     MOV W4, W0
003B74  07FC76     RCALL readBytes
003B76  780200     MOV W0, W4
003B78  780F04     MOV W4, [W14]
003B7A  37000D     BRA 0x3B96
531:               	else if (Rx.frameControl.dstAddrMode == LONG_ADDR_FIELD)		// if a long dest addr is present
003B7C  80FED5     MOV 0x1FDA, W5
003B7E  20C004     MOV #0xC00, W4
003B80  628284     AND W5, W4, W5
003B82  20C004     MOV #0xC00, W4
003B84  528F84     SUB W5, W4, [W15]
003B86  3A0007     BRA NZ, 0x3B96
532:               		readPoint = readBytes(BYTEPTR(Rx.dstAddr), readPoint, 8);
003B88  21FE04     MOV #0x1FE0, W4
003B8A  200082     MOV #0x8, W2
003B8C  78009E     MOV [W14], W1
003B8E  780004     MOV W4, W0
003B90  07FC68     RCALL readBytes
003B92  780200     MOV W0, W4
003B94  780F04     MOV W4, [W14]
533:               
534:               	Rx.srcPANID = Rx.dstPANID;						// copy first PANID because we don't know if it's src or dst yet
003B96  80FEF4     MOV 0x1FDE, W4
003B98  88FF44     MOV W4, 0x1FE8
535:               	Rx.srcAddr = Rx.dstAddr;						// ditto for address
003B9A  21FE04     MOV #0x1FE0, W4
003B9C  BE0354     MOV.D [++W4], W6
003B9E  BE0244     MOV.D [--W4], W4
003BA0  21FEA0     MOV #0x1FEA, W0
003BA2  BE9804     MOV.D W4, [W0++]
003BA4  BE9006     MOV.D W6, [W0--]
536:               
537:               	// now readPoint is at start of source PANID (if present)
538:               
539:               	if ( Rx.frameControl.srcAddrMode != NO_ADDR_FIELD &&			// if source present
003BA6  80FED5     MOV 0x1FDA, W5
003BA8  2C0004     MOV #0xC000, W4
003BAA  628204     AND W5, W4, W4
003BAC  520FE0     SUB W4, #0x0, [W15]
003BAE  320011     BRA Z, 0x3BD2
003BB6  520FE0     SUB W4, #0x0, [W15]
003BB8  32000C     BRA Z, 0x3BD2
540:               		 Rx.frameControl.dstAddrMode != NO_ADDR_FIELD &&		// and dest present
003BB0  80FED5     MOV 0x1FDA, W5
003BB2  20C004     MOV #0xC00, W4
003BB4  628204     AND W5, W4, W4
003BC0  520FE0     SUB W4, #0x0, [W15]
003BC2  3A0007     BRA NZ, 0x3BD2
541:               		 !Rx.frameControl.panIDcomp )					// and no PANID compression
003BBA  80FED5     MOV 0x1FDA, W5
003BBC  200404     MOV #0x40, W4
003BBE  628204     AND W5, W4, W4
542:               			readPoint = readBytes(BYTEPTR(Rx.srcPANID),readPoint, 2);	// then read src PANID
003BC4  21FE84     MOV #0x1FE8, W4
003BC6  200022     MOV #0x2, W2
003BC8  78009E     MOV [W14], W1
003BCA  780004     MOV W4, W0
003BCC  07FC4A     RCALL readBytes
003BCE  780200     MOV W0, W4
003BD0  780F04     MOV W4, [W14]
543:               		
544:               	if (Rx.frameControl.srcAddrMode == SHORT_ADDR_FIELD){			// if a short src addr is present
003BD2  80FED5     MOV 0x1FDA, W5
003BD4  2C0004     MOV #0xC000, W4
003BD6  628284     AND W5, W4, W5
003BD8  280004     MOV #0x8000, W4
003BDA  528F84     SUB W5, W4, [W15]
003BDC  3A0008     BRA NZ, 0x3BEE
545:               		readPoint = readBytes(BYTEPTR(Rx.srcAddr),readPoint, 2);
003BDE  21FEA4     MOV #0x1FEA, W4
003BE0  200022     MOV #0x2, W2
003BE2  78009E     MOV [W14], W1
003BE4  780004     MOV W4, W0
003BE6  07FC3D     RCALL readBytes
003BE8  780200     MOV W0, W4
003BEA  780F04     MOV W4, [W14]
003BEC  37000D     BRA 0x3C08
546:               	} else if (Rx.frameControl.srcAddrMode == LONG_ADDR_FIELD){		// if a long src addr is present
003BEE  80FED5     MOV 0x1FDA, W5
003BF0  2C0004     MOV #0xC000, W4
003BF2  628284     AND W5, W4, W5
003BF4  2C0004     MOV #0xC000, W4
003BF6  528F84     SUB W5, W4, [W15]
003BF8  3A0007     BRA NZ, 0x3C08
547:               		readPoint = readBytes(BYTEPTR(Rx.srcAddr),readPoint,8);
003BFA  21FEA4     MOV #0x1FEA, W4
003BFC  200082     MOV #0x8, W2
003BFE  78009E     MOV [W14], W1
003C00  780004     MOV W4, W0
003C02  07FC2F     RCALL readBytes
003C04  780200     MOV W0, W4
003C06  780F04     MOV W4, [W14]
548:               	}	
549:               	
550:               	Rx.payload = readPoint;							// now readPoint points at the start of the payload
003C08  78021E     MOV [W14], W4
003C0A  88FFA4     MOV W4, 0x1FF4
551:               	Rx.payloadLength = Rx.frameLength - (readPoint - RXBuffer[RadioStatus.RXReadBuffer]) + 1;
003C0C  21FD86     MOV #0x1FD8, W6
003C0E  784316     MOV.B [W6], W6
003C10  21E987     MOV #0x1E98, W7
003C12  21E744     MOV #0x1E74, W4
003C14  784214     MOV.B [W4], W4
003C16  FB8284     ZE W4, W5
003C18  200904     MOV #0x90, W4
003C1A  B9AA04     MUL.SS W5, W4, W4
003C1C  780204     MOV W4, W4
003C1E  438204     ADD W7, W4, W4
003C20  784284     MOV.B W4, W5
003C22  78021E     MOV [W14], W4
003C24  784204     MOV.B W4, W4
003C26  52C204     SUB.B W5, W4, W4
003C28  434204     ADD.B W6, W4, W4
003C2A  E84204     INC.B W4, W4
003C2C  780004     MOV W4, W0
003C2E  B7FFF2     MOV.B WREG, 0x1FF2
552:               
553:               	Rx.lqi = RXBuffer[RadioStatus.RXReadBuffer][RXBuffer[RadioStatus.RXReadBuffer][0]+3];
003C30  21E744     MOV #0x1E74, W4
003C32  784214     MOV.B [W4], W4
003C34  FB8384     ZE W4, W7
003C36  21E744     MOV #0x1E74, W4
003C38  784214     MOV.B [W4], W4
003C3A  FB8284     ZE W4, W5
003C3C  200904     MOV #0x90, W4
003C3E  B9AA04     MUL.SS W5, W4, W4
003C40  780284     MOV W4, W5
003C42  21E984     MOV #0x1E98, W4
003C44  428204     ADD W5, W4, W4
003C46  784214     MOV.B [W4], W4
003C48  FB8204     ZE W4, W4
003C4A  420363     ADD W4, #0x3, W6
003C4C  200904     MOV #0x90, W4
003C4E  B9BA04     MUL.SS W7, W4, W4
003C50  780204     MOV W4, W4
003C52  420286     ADD W4, W6, W5
003C54  21E984     MOV #0x1E98, W4
003C56  428204     ADD W5, W4, W4
003C58  784214     MOV.B [W4], W4
003C5A  780004     MOV W4, W0
003C5C  B7FFF6     MOV.B WREG, 0x1FF6
554:               	Rx.rssi = RXBuffer[RadioStatus.RXReadBuffer][RXBuffer[RadioStatus.RXReadBuffer][0]+4];
003C5E  21E744     MOV #0x1E74, W4
003C60  784214     MOV.B [W4], W4
003C62  FB8384     ZE W4, W7
003C64  21E744     MOV #0x1E74, W4
003C66  784214     MOV.B [W4], W4
003C68  FB8284     ZE W4, W5
003C6A  200904     MOV #0x90, W4
003C6C  B9AA04     MUL.SS W5, W4, W4
003C6E  780284     MOV W4, W5
003C70  21E984     MOV #0x1E98, W4
003C72  428204     ADD W5, W4, W4
003C74  784214     MOV.B [W4], W4
003C76  FB8204     ZE W4, W4
003C78  420364     ADD W4, #0x4, W6
003C7A  200904     MOV #0x90, W4
003C7C  B9BA04     MUL.SS W7, W4, W4
003C7E  780204     MOV W4, W4
003C80  420286     ADD W4, W6, W5
003C82  21E984     MOV #0x1E98, W4
003C84  428204     ADD W5, W4, W4
003C86  784214     MOV.B [W4], W4
003C88  780004     MOV W4, W0
003C8A  B7FFF7     MOV.B WREG, 0x1FF7
555:               
556:               	return RadioStatus.RXPacketCount;
003C8C  21E754     MOV #0x1E75, W4
003C8E  784214     MOV.B [W4], W4
557:               }
003C90  784004     MOV.B W4, W0
003C92  FA8000     ULNK
003C94  060000     RETURN
558:               
559:               void RadioDiscardPacket(void)
560:               {
003C96  FA0000     LNK #0x0
561:               	if (RadioStatus.RXPacketCount){						// just in case we get called more than we ought
003C98  21E754     MOV #0x1E75, W4
003C9A  784214     MOV.B [W4], W4
003C9C  524FE0     SUB.B W4, #0x0, [W15]
003C9E  32000E     BRA Z, 0x3CBC
562:               		RadioStatus.RXPacketCount--;
003CA0  21E754     MOV #0x1E75, W4
003CA2  784214     MOV.B [W4], W4
003CA4  E94204     DEC.B W4, W4
003CA6  FD0200     EXCH W0, W4
003CA8  B7FE75     MOV.B WREG, 0x1E75
003CAA  FD0200     EXCH W0, W4
563:               		RadioStatus.RXReadBuffer = (RadioStatus.RXReadBuffer + 1) & (PACKET_BUFFERS - 1);
003CAC  21E744     MOV #0x1E74, W4
003CAE  784214     MOV.B [W4], W4
003CB0  E84204     INC.B W4, W4
003CB2  624261     AND.B W4, #0x1, W4
003CB4  FD0200     EXCH W0, W4
003CB6  B7FE74     MOV.B WREG, 0x1E74
003CB8  FD0200     EXCH W0, W4
003CBA  370003     BRA 0x3CC2
564:               	} else {
565:               		RadioStatus.RadioExtraDiscard++;
003CBC  80F494     MOV 0x1E92, W4
003CBE  E80204     INC W4, W4
003CC0  88F494     MOV W4, 0x1E92
566:               	}	
567:               }
003CC2  FA8000     ULNK
003CC4  060000     RETURN
568:               
569:               #if (RADIO_INT==0)
570:               void __attribute__((interrupt,shadow,auto_psv)) _INT0Interrupt(void)
571:               #elif (RADIO_INT==1)
572:               void __attribute__((interrupt,shadow,auto_psv)) _INT1Interrupt(void)
573:               #elif (RADIO_INT==2)
574:               void __attribute__((interrupt,shadow,auto_psv)) _INT2Interrupt(void)
575:               #endif
576:               {
003CC6  FEA000     PUSH.S
003CC8  F80036     PUSH RCOUNT
003CCA  BE9F84     MOV.D W4, [W15++]
003CCC  BE9F86     MOV.D W6, [W15++]
003CCE  BE9F88     MOV.D W8, [W15++]
003CD0  F80034     PUSH PSVPAG
003CD2  200004     MOV #0x0, W4
003CD4  8801A4     MOV W4, PSVPAG
003CD6  FA0006     LNK #0x6
577:               
578:               	MRF24J40_IFREG iflags;
579:               
580:               	RADIO_IF = 0;								// clear IF immediately to allow next interrupt
003CD8  A98086     BCLR IFS1, #4
581:               
582:               	iflags.Val = lowRead(READ_ISRSTS);                                      // read ISR to see what caused the interrupt
003CDA  B3C620     MOV.B #0x62, W0
003CDC  07FC63     RCALL lowRead
003CDE  784200     MOV.B W0, W4
003CE0  984734     MOV.B W4, [W14+3]
583:               
584:               	if(iflags.bits.RXIF){							// RX int?
003CE2  90423E     MOV.B [W14+3], W4
003CE4  624268     AND.B W4, #0x8, W4
003CE6  524FE0     SUB.B W4, #0x0, [W15]
003CE8  320056     BRA Z, 0x3D96
585:               		UINT8 i, bytes;
586:               
587:               		lowWrite(WRITE_BBREG1, 0x04);					// set RXDECINV to disable hw RX while we're reading the FIFO
003CEA  B3C041     MOV.B #0x4, W1
003CEC  B3C730     MOV.B #0x73, W0
003CEE  07FC76     RCALL lowWrite
588:               
589:               		bytes = highRead(0x300) + 2;					// get the size of the packet w/FCS, + 2 more bytes for RSSI and LQI
003CF0  203000     MOV #0x300, W0
003CF2  07FC0B     RCALL highRead
003CF4  784200     MOV.B W0, W4
003CF6  E8C204     INC2.B W4, W4
003CF8  984714     MOV.B W4, [W14+1]
590:               
591:               		if( bytes > RX_BUFFER_SIZE){					// if too big for the RX buffer
003CFA  90429E     MOV.B [W14+1], W5
003CFC  B3C904     MOV.B #0x90, W4
003CFE  52CF84     SUB.B W5, W4, [W15]
003D00  360005     BRA LEU, 0x3D0C
592:               			RadioStatus.RXPacketTooBig++;
003D02  80F4A4     MOV 0x1E94, W4
003D04  E80204     INC W4, W4
003D06  88F4A4     MOV W4, 0x1E94
593:               			bytes = RX_BUFFER_SIZE;					// truncate to fit
003D08  B3C904     MOV.B #0x90, W4
003D0A  984714     MOV.B W4, [W14+1]
594:               		}
595:               
596:               		RXBuffer[RadioStatus.RXWriteBuffer][0] = bytes - 4;		// store length of packet (not counting length byte, FCS, LQI and RSSI)
003D0C  21E734     MOV #0x1E73, W4
003D0E  784214     MOV.B [W4], W4
003D10  FB8284     ZE W4, W5
003D12  90421E     MOV.B [W14+1], W4
003D14  524364     SUB.B W4, #0x4, W6
003D16  200904     MOV #0x90, W4
003D18  B9AA04     MUL.SS W5, W4, W4
003D1A  780284     MOV W4, W5
003D1C  21E984     MOV #0x1E98, W4
003D1E  428204     ADD W5, W4, W4
003D20  784A06     MOV.B W6, [W4]
597:               
598:               		for(i=1;i<=bytes;i++){						// copy data from the FIFO into the RX buffer, plus RSSI and LQI
003D22  B3C014     MOV.B #0x1, W4
003D24  784F04     MOV.B W4, [W14]
003D26  370013     BRA 0x3D4E
003D4C  E84F1E     INC.B [W14], [W14]
003D4E  90421E     MOV.B [W14+1], W4
003D50  78429E     MOV.B [W14], W5
003D52  52CF84     SUB.B W5, W4, [W15]
003D54  36FFE9     BRA LEU, 0x3D28
599:               			RXBuffer[RadioStatus.RXWriteBuffer][i] = highRead(0x300+i);
003D28  21E734     MOV #0x1E73, W4
003D2A  784214     MOV.B [W4], W4
003D2C  FB8484     ZE W4, W9
003D2E  78421E     MOV.B [W14], W4
003D30  FB8404     ZE W4, W8
003D32  78429E     MOV.B [W14], W5
003D34  FB8205     ZE W5, W4
003D36  B03004     ADD #0x300, W4
003D38  780004     MOV W4, W0
003D3A  07FBE7     RCALL highRead
003D3C  784300     MOV.B W0, W6
003D3E  200904     MOV #0x90, W4
003D40  B9CA04     MUL.SS W9, W4, W4
003D42  780204     MOV W4, W4
003D44  420288     ADD W4, W8, W5
003D46  21E984     MOV #0x1E98, W4
003D48  428204     ADD W5, W4, W4
003D4A  784A06     MOV.B W6, [W4]
600:               		}	
601:               
602:               		RadioStatus.RXPacketCount++;
003D56  21E754     MOV #0x1E75, W4
003D58  784214     MOV.B [W4], W4
003D5A  E84204     INC.B W4, W4
003D5C  FD0200     EXCH W0, W4
003D5E  B7FE75     MOV.B WREG, 0x1E75
003D60  FD0200     EXCH W0, W4
603:               		RadioStatus.RXWriteBuffer = (RadioStatus.RXWriteBuffer+1) & (PACKET_BUFFERS-1);	// mod PACKET_BUFFERS
003D62  21E734     MOV #0x1E73, W4
003D64  784214     MOV.B [W4], W4
003D66  E84204     INC.B W4, W4
003D68  624261     AND.B W4, #0x1, W4
003D6A  FD0200     EXCH W0, W4
003D6C  B7FE73     MOV.B WREG, 0x1E73
003D6E  FD0200     EXCH W0, W4
604:               
605:               		if ( (RadioStatus.RXPacketCount > PACKET_BUFFERS) || (RadioStatus.RXWriteBuffer == RadioStatus.RXReadBuffer) ){
003D70  21E754     MOV #0x1E75, W4
003D72  784214     MOV.B [W4], W4
003D74  524FE2     SUB.B W4, #0x2, [W15]
003D76  3E0006     BRA GTU, 0x3D84
003D78  21E735     MOV #0x1E73, W5
003D7A  784295     MOV.B [W5], W5
003D7C  21E744     MOV #0x1E74, W4
003D7E  784214     MOV.B [W4], W4
003D80  52CF84     SUB.B W5, W4, [W15]
003D82  3A0003     BRA NZ, 0x3D8A
606:               			RadioStatus.RXBufferOverruns++;
003D84  80F4B4     MOV 0x1E96, W4
003D86  E80204     INC W4, W4
003D88  88F4B4     MOV W4, 0x1E96
607:               		}	
608:               
609:               		lowWrite(WRITE_RXFLUSH,0x01);					// flush RX hw FIFO manually (workaround for silicon errata #1)
003D8A  B3C011     MOV.B #0x1, W1
003D8C  B3C1B0     MOV.B #0x1B, W0
003D8E  07FC26     RCALL lowWrite
610:               		lowWrite(WRITE_BBREG1, 0x00);					// reset RXDECINV to enable radio to receive next packet
003D90  EB4080     CLR.B W1
003D92  B3C730     MOV.B #0x73, W0
003D94  07FC23     RCALL lowWrite
611:               	}
612:               
613:               	if(iflags.bits.TXIF){							// TX int?  If so, this means TX is no longer busy, and the result (if any) of the ACK request is in
003D96  90423E     MOV.B [W14+3], W4
003D98  624261     AND.B W4, #0x1, W4
003D9A  524FE0     SUB.B W4, #0x0, [W15]
003D9C  320024     BRA Z, 0x3DE6
614:               		RadioStatus.TX_BUSY = 0;					// clear busy flag (TX is complete now)
003D9E  A91E72     BCLR RadioStatus, #0
615:               
616:               		if(RadioStatus.TX_PENDING_ACK){					// if we were waiting for an ACK
003DA0  80F394     MOV RadioStatus, W4
003DA2  620262     AND W4, #0x2, W4
003DA4  520FE0     SUB W4, #0x0, [W15]
003DA6  32001F     BRA Z, 0x3DE6
617:               			UINT8 TXSTAT = lowRead(READ_TXSR);			// read TXSTAT, transmit status register
003DA8  B3C480     MOV.B #0x48, W0
003DAA  07FBFC     RCALL lowRead
003DAC  784200     MOV.B W0, W4
003DAE  984724     MOV.B W4, [W14+2]
618:               			RadioStatus.TX_FAIL    = TXSTAT & 1;			// read TXNSTAT (TX failure status)
003DB0  90422E     MOV.B [W14+2], W4
003DB2  624261     AND.B W4, #0x1, W4
003DB4  624261     AND.B W4, #0x1, W4
003DB6  624261     AND.B W4, #0x1, W4
003DB8  FB8204     ZE W4, W4
003DBA  620261     AND W4, #0x1, W4
003DBC  DD2242     SL W4, #2, W4
003DBE  80F396     MOV RadioStatus, W6
003DC0  2FFFB5     MOV #0xFFFB, W5
003DC2  630285     AND W6, W5, W5
003DC4  720205     IOR W4, W5, W4
003DC6  88F394     MOV W4, RadioStatus
619:               			RadioStatus.TX_RETRIES = TXSTAT >> 6;			// read TXNRETRY, number of retries of last sent packet (0..3)
003DC8  90422E     MOV.B [W14+2], W4
003DCA  FB8204     ZE W4, W4
003DCC  DE2246     LSR W4, #6, W4
003DCE  784204     MOV.B W4, W4
003DD0  624263     AND.B W4, #0x3, W4
003DD2  FB8204     ZE W4, W4
003DD4  620263     AND W4, #0x3, W4
003DD6  DD2243     SL W4, #3, W4
003DD8  80F396     MOV RadioStatus, W6
003DDA  2FFE75     MOV #0xFFE7, W5
003DDC  630285     AND W6, W5, W5
003DDE  720205     IOR W4, W5, W4
003DE0  88F394     MOV W4, RadioStatus
620:               			RadioStatus.TX_CCAFAIL = TXSTAT & 0b00100000;           // read CCAFAIL
003DE2  A9BE72     BCLR RadioStatus, #5
621:               
622:               			RadioStatus.TX_PENDING_ACK = 0;				// TX finished, clear that I am pending an ACK, already got it (if I was gonna get it)
003DE4  A93E72     BCLR RadioStatus, #1
623:               		}
624:               	}
625:               }
003DE6  FA8000     ULNK
003DE8  F90034     POP PSVPAG
003DEA  BE044F     MOV.D [--W15], W8
003DEC  BE034F     MOV.D [--W15], W6
003DEE  BE024F     MOV.D [--W15], W4
003DF0  F90036     POP RCOUNT
003DF2  FE8000     POP.S
003DF4  064000     RETFIE
626:               
627:               #undef _IN_MRF24J40_
628:               
629:               
630:               
631:               
---  C:/Users/Chase/Desktop/ecen-4013-spring2014-mchammer/src/HammerState.c  ----------------------------
1:                 #include <stdlib.h>
2:                 #include <xc.h>
3:                 
4:                 #include "cm_uart.h"
5:                 #include "HammerState.h"
6:                 
7:                 static volatile HammerState hState;
8:                 
9:                 void initHammerState() {
004824  FA0000     LNK #0x0
10:                    hState.health = 0.0;
004826  B82260     MUL.UU W4, #0, W4
004828  88F0D4     MOV W4, hState
00482A  88F0E5     MOV W5, 0x1E1C
11:                    hState.chargeStatus = 0.0;
00482C  B82260     MUL.UU W4, #0, W4
00482E  88F0F4     MOV W4, 0x1E1E
004830  88F105     MOV W5, 0x1E20
12:                    hState.chargeRate = 20.0;        // Charge / sec
004832  200004     MOV #0x0, W4
004834  241A05     MOV #0x41A0, W5
004836  88F114     MOV W4, 0x1E22
004838  88F125     MOV W5, 0x1E24
13:                    hState.charging = 0;
00483A  EB0200     CLR W4
00483C  88F134     MOV W4, 0x1E26
14:                }
00483E  FA8000     ULNK
004840  060000     RETURN
15:                
16:                HammerState * getHammerStatePtr() {
004842  FA0000     LNK #0x0
17:                    return (HammerState *)&hState;
004844  21E1A4     MOV #0x1E1A, W4
18:                }
004846  780004     MOV W4, W0
004848  FA8000     ULNK
00484A  060000     RETURN
19:                
20:                void HammerState_doCharge(double dt) {
00484C  FA0004     LNK #0x4
00484E  BE9F88     MOV.D W8, [W15++]
004850  BE8F00     MOV.D W0, [W14]
21:                    hState.chargeStatus += dt * hState.chargeRate;
004852  80F0F8     MOV 0x1E1E, W8
004854  80F109     MOV 0x1E20, W9
004856  80F114     MOV 0x1E22, W4
004858  80F125     MOV 0x1E24, W5
00485A  BE011E     MOV.D [W14], W2
00485C  BE0004     MOV.D W4, W0
00485E  07DE58     RCALL ___mulsf3
004860  BE0200     MOV.D W0, W4
004862  BE0104     MOV.D W4, W2
004864  BE0008     MOV.D W8, W0
004866  07DD75     RCALL ___addsf3
004868  BE0200     MOV.D W0, W4
00486A  88F0F4     MOV W4, 0x1E1E
00486C  88F105     MOV W5, 0x1E20
22:                }
00486E  BE044F     MOV.D [--W15], W8
004870  FA8000     ULNK
004872  060000     RETURN
---  C:/Users/Chase/Desktop/ecen-4013-spring2014-mchammer/src/Common.c  ---------------------------------
1:                 #include <stdio.h>
2:                 #include <stdlib.h>
3:                 
4:                 #include <xc.h>
5:                 
6:                 #include "Common.h"
7:                 
8:                 int tIEC1, tIEC2, tIEC3, tIEC4;
9:                 
10:                void INT_OFF() {
004874  FA0000     LNK #0x0
11:                    tIEC1 = IEC1;
004876  8004B4     MOV IEC1, W4
004878  88F094     MOV W4, tIEC1
12:                    tIEC2 = IEC2;
00487A  8004C4     MOV IEC2, W4
00487C  88F0A4     MOV W4, tIEC2
13:                    tIEC3 = IEC3;
00487E  8004D4     MOV IEC3, W4
004880  88F0B4     MOV W4, tIEC3
14:                    tIEC4 = IEC4;
004882  8004E4     MOV IEC4, W4
004884  88F0C4     MOV W4, tIEC4
15:                    IEC1 = 0;
004886  EB0200     CLR W4
004888  8804B4     MOV W4, IEC1
16:                    IEC2 = 0;
00488A  EB0200     CLR W4
00488C  8804C4     MOV W4, IEC2
17:                    IEC3 = 0;
00488E  EB0200     CLR W4
004890  8804D4     MOV W4, IEC3
18:                    IEC4 = 0;
004892  EB0200     CLR W4
004894  8804E4     MOV W4, IEC4
19:                }
004896  FA8000     ULNK
004898  060000     RETURN
20:                
21:                void INT_ON() {
00489A  FA0000     LNK #0x0
22:                    IEC1 = tIEC1;
00489C  80F094     MOV tIEC1, W4
00489E  8804B4     MOV W4, IEC1
23:                    IEC2 = tIEC2;
0048A0  80F0A4     MOV tIEC2, W4
0048A2  8804C4     MOV W4, IEC2
24:                    IEC3 = tIEC3;
0048A4  80F0B4     MOV tIEC3, W4
0048A6  8804D4     MOV W4, IEC3
25:                    IEC4 = tIEC4;
0048A8  80F0C4     MOV tIEC4, W4
0048AA  8804E4     MOV W4, IEC4
26:                }
0048AC  FA8000     ULNK
0048AE  060000     RETURN
